\hypertarget{recovery_2main__impl_8h}{}\section{/home/dev/ds-\/160209/src/secp256k1/src/modules/recovery/main\+\_\+impl.h File Reference}
\label{recovery_2main__impl_8h}\index{/home/dev/ds-\/160209/src/secp256k1/src/modules/recovery/main\+\_\+impl.\+h@{/home/dev/ds-\/160209/src/secp256k1/src/modules/recovery/main\+\_\+impl.\+h}}
{\ttfamily \#include \char`\"{}include/secp256k1\+\_\+recovery.\+h\char`\"{}}\\*
Include dependency graph for main\+\_\+impl.\+h\+:
% FIG 0
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{recovery_2main__impl_8h_a37101568f72e98d7b29de6c6a825a289}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__ecdsa__recoverable__signature}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig, const unsigned char $\ast$input64, int recid)
\item 
int \hyperlink{recovery_2main__impl_8h_ac122392fa6ff6264a7a110875af164b0}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$output64, int $\ast$recid, const \hyperlink{structsecp256k1__ecdsa__recoverable__signature}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sig)
\item 
int \hyperlink{recovery_2main__impl_8h_a16ddfc800140d761bc783e571c34548c}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__ecdsa__signature}{secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$sig, const \hyperlink{structsecp256k1__ecdsa__recoverable__signature}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$sigin)
\item 
int \hyperlink{recovery_2main__impl_8h_ae06d019b6eaa34e248a502ba9c6d04cb}{secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__ecdsa__recoverable__signature}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$signature, const unsigned char $\ast$msg32, const unsigned char $\ast$seckey, \hyperlink{secp256k1_8h_a539882fd91bff672712fa19a4cfaeb98}{secp256k1\+\_\+nonce\+\_\+function} noncefp, const void $\ast$noncedata)
\item 
int \hyperlink{recovery_2main__impl_8h_a75f3e32e9a25eac9e8f9d3a5a8b0dc94}{secp256k1\+\_\+ecdsa\+\_\+recover} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__pubkey}{secp256k1\+\_\+pubkey} $\ast$pubkey, const \hyperlink{structsecp256k1__ecdsa__recoverable__signature}{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$signature, const unsigned char $\ast$msg32)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{recovery_2main__impl_8h_a75f3e32e9a25eac9e8f9d3a5a8b0dc94}{}\index{recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}!secp256k1\+\_\+ecdsa\+\_\+recover@{secp256k1\+\_\+ecdsa\+\_\+recover}}
\index{secp256k1\+\_\+ecdsa\+\_\+recover@{secp256k1\+\_\+ecdsa\+\_\+recover}!recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+ecdsa\+\_\+recover}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+ecdsa\+\_\+recover (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+pubkey} $\ast$}]{pubkey, }
\item[{const {\bf secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig, }
\item[{const unsigned char $\ast$}]{msg32}
\end{DoxyParamCaption}
)}\label{recovery_2main__impl_8h_a75f3e32e9a25eac9e8f9d3a5a8b0dc94}
Recover an E\+C\+D\+S\+A public key from a signature.

Returns\+: 1\+: public key successfully recovered (which guarantees a correct signature). 0\+: otherwise. Args\+: ctx\+: pointer to a context object, initialized for verification (cannot be N\+U\+L\+L) Out\+: pubkey\+: pointer to the recovered public key (cannot be N\+U\+L\+L) In\+: sig\+: pointer to initialized signature that supports pubkey recovery (cannot be N\+U\+L\+L) msg32\+: the 32-\/byte message hash assumed to be signed (cannot be N\+U\+L\+L) 

Definition at line 170 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 1


\hypertarget{recovery_2main__impl_8h_a16ddfc800140d761bc783e571c34548c}{}\index{recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}!secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}}
\index{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}!recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+convert (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+ecdsa\+\_\+signature} $\ast$}]{sig, }
\item[{const {\bf secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sigin}
\end{DoxyParamCaption}
)}\label{recovery_2main__impl_8h_a16ddfc800140d761bc783e571c34548c}
Convert a recoverable signature into a normal signature.

Returns\+: 1 Out\+: sig\+: a pointer to a normal signature (cannot be N\+U\+L\+L). In\+: sigin\+: a pointer to a recoverable signature (cannot be N\+U\+L\+L). 

Definition at line 74 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 2


\hypertarget{recovery_2main__impl_8h_a37101568f72e98d7b29de6c6a825a289}{}\index{recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}!secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact}}
\index{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact}!recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+parse\+\_\+compact (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig, }
\item[{const unsigned char $\ast$}]{input64, }
\item[{int}]{recid}
\end{DoxyParamCaption}
)}\label{recovery_2main__impl_8h_a37101568f72e98d7b29de6c6a825a289}
Parse a compact E\+C\+D\+S\+A signature (64 bytes + recovery id).

Returns\+: 1 when the signature could be parsed, 0 otherwise Args\+: ctx\+: a secp256k1 context object Out\+: sig\+: a pointer to a signature object In\+: input64\+: a pointer to a 64-\/byte compact signature recid\+: the recovery id (0, 1, 2 or 3) 

Definition at line 38 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 3


\hypertarget{recovery_2main__impl_8h_ac122392fa6ff6264a7a110875af164b0}{}\index{recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}!secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact}}
\index{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact@{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact}!recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature\+\_\+serialize\+\_\+compact (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{unsigned char $\ast$}]{output64, }
\item[{int $\ast$}]{recid, }
\item[{const {\bf secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig}
\end{DoxyParamCaption}
)}\label{recovery_2main__impl_8h_ac122392fa6ff6264a7a110875af164b0}
Serialize an E\+C\+D\+S\+A signature in compact format (64 bytes + recovery id).

Returns\+: 1 Args\+: ctx\+: a secp256k1 context object Out\+: output64\+: a pointer to a 64-\/byte array of the compact signature (cannot be N\+U\+L\+L) recid\+: a pointer to an integer to hold the recovery id (can be N\+U\+L\+L). In\+: sig\+: a pointer to an initialized signature object (cannot be N\+U\+L\+L) 

Definition at line 60 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 4


\hypertarget{recovery_2main__impl_8h_ae06d019b6eaa34e248a502ba9c6d04cb}{}\index{recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}!secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable@{secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable}}
\index{secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable@{secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable}!recovery/main\+\_\+impl.\+h@{recovery/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+ecdsa\+\_\+sign\+\_\+recoverable (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+ecdsa\+\_\+recoverable\+\_\+signature} $\ast$}]{sig, }
\item[{const unsigned char $\ast$}]{msg32, }
\item[{const unsigned char $\ast$}]{seckey, }
\item[{{\bf secp256k1\+\_\+nonce\+\_\+function}}]{noncefp, }
\item[{const void $\ast$}]{ndata}
\end{DoxyParamCaption}
)}\label{recovery_2main__impl_8h_ae06d019b6eaa34e248a502ba9c6d04cb}
Create a recoverable E\+C\+D\+S\+A signature.

Returns\+: 1\+: signature created 0\+: the nonce generation function failed, or the private key was invalid. Args\+: ctx\+: pointer to a context object, initialized for signing (cannot be N\+U\+L\+L) Out\+: sig\+: pointer to an array where the signature will be placed (cannot be N\+U\+L\+L) In\+: msg32\+: the 32-\/byte message hash being signed (cannot be N\+U\+L\+L) seckey\+: pointer to a 32-\/byte secret key (cannot be N\+U\+L\+L) noncefp\+:pointer to a nonce generation function. If N\+U\+L\+L, secp256k1\+\_\+nonce\+\_\+function\+\_\+default is used ndata\+: pointer to arbitrary data used by the nonce generation function (can be N\+U\+L\+L) 

Definition at line 123 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 5


