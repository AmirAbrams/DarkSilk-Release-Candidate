\hypertarget{schnorr_2main__impl_8h}{}\section{/home/dev/ds-\/160209/src/secp256k1/src/modules/schnorr/main\+\_\+impl.h File Reference}
\label{schnorr_2main__impl_8h}\index{/home/dev/ds-\/160209/src/secp256k1/src/modules/schnorr/main\+\_\+impl.\+h@{/home/dev/ds-\/160209/src/secp256k1/src/modules/schnorr/main\+\_\+impl.\+h}}
{\ttfamily \#include \char`\"{}include/secp256k1\+\_\+schnorr.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}modules/schnorr/schnorr\+\_\+impl.\+h\char`\"{}}\\*
Include dependency graph for main\+\_\+impl.\+h\+:
% FIG 0
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{schnorr_2main__impl_8h_a0d7ae4600f16da7c9464c80fefc72072}{secp256k1\+\_\+schnorr\+\_\+sign} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$msg32, const unsigned char $\ast$seckey, \hyperlink{secp256k1_8h_a539882fd91bff672712fa19a4cfaeb98}{secp256k1\+\_\+nonce\+\_\+function} noncefp, const void $\ast$noncedata)
\item 
int \hyperlink{schnorr_2main__impl_8h_a5d23afb11115cb53171b34da09ff3ad0}{secp256k1\+\_\+schnorr\+\_\+verify} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, const unsigned char $\ast$sig64, const unsigned char $\ast$msg32, const \hyperlink{structsecp256k1__pubkey}{secp256k1\+\_\+pubkey} $\ast$pubkey)
\item 
int \hyperlink{schnorr_2main__impl_8h_aa4480a44de97ffc056712ea9fd9631c5}{secp256k1\+\_\+schnorr\+\_\+recover} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__pubkey}{secp256k1\+\_\+pubkey} $\ast$pubkey, const unsigned char $\ast$sig64, const unsigned char $\ast$msg32)
\item 
int \hyperlink{schnorr_2main__impl_8h_a67c4e4b188db3530c2e8808162f3a3c5}{secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, \hyperlink{structsecp256k1__pubkey}{secp256k1\+\_\+pubkey} $\ast$pubnonce, unsigned char $\ast$privnonce32, const unsigned char $\ast$sec32, const unsigned char $\ast$msg32, \hyperlink{secp256k1_8h_a539882fd91bff672712fa19a4cfaeb98}{secp256k1\+\_\+nonce\+\_\+function} noncefp, const void $\ast$noncedata)
\item 
int \hyperlink{schnorr_2main__impl_8h_a6787237abf20a26c8c2fb195102ce810}{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$msg32, const unsigned char $\ast$sec32, const \hyperlink{structsecp256k1__pubkey}{secp256k1\+\_\+pubkey} $\ast$pubnonce\+\_\+others, const unsigned char $\ast$secnonce32)
\item 
int \hyperlink{schnorr_2main__impl_8h_a7dd43d7414424c68563e14d0bda8e867}{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine} (const \hyperlink{secp256k1_8h_a282ec9e6dfec8c35955c3eb2f7476e5e}{secp256k1\+\_\+context} $\ast$ctx, unsigned char $\ast$sig64, const unsigned char $\ast$const $\ast$sig64sin, size\+\_\+t n)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\hypertarget{schnorr_2main__impl_8h_a67c4e4b188db3530c2e8808162f3a3c5}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair@{secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair}}
\index{secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair@{secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+pubkey} $\ast$}]{pubnonce, }
\item[{unsigned char $\ast$}]{privnonce32, }
\item[{const unsigned char $\ast$}]{msg32, }
\item[{const unsigned char $\ast$}]{sec32, }
\item[{{\bf secp256k1\+\_\+nonce\+\_\+function}}]{noncefp, }
\item[{const void $\ast$}]{noncedata}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_a67c4e4b188db3530c2e8808162f3a3c5}
Generate a nonce pair deterministically for use with secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign. Returns\+: 1\+: valid nonce pair was generated. 0\+: otherwise (nonce generation function failed) Args\+: ctx\+: pointer to a context object, initialized for signing (cannot be N\+U\+L\+L) Out\+: pubnonce\+: public side of the nonce (cannot be N\+U\+L\+L) privnonce32\+: private side of the nonce (32 byte) (cannot be N\+U\+L\+L) In\+: msg32\+: the 32-\/byte message hash assumed to be signed (cannot be N\+U\+L\+L) sec32\+: the 32-\/byte private key (cannot be N\+U\+L\+L) noncefp\+: pointer to a nonce generation function. If N\+U\+L\+L, secp256k1\+\_\+nonce\+\_\+function\+\_\+default is used noncedata\+: pointer to arbitrary data used by the nonce generation function (can be N\+U\+L\+L)

Do not use the output as a private/public key pair for signing/validation. 

Definition at line 91 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 1


\hypertarget{schnorr_2main__impl_8h_a7dd43d7414424c68563e14d0bda8e867}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine@{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine}}
\index{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine@{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{unsigned char $\ast$}]{sig64, }
\item[{const unsigned char $\ast$const $\ast$}]{sig64sin, }
\item[{size\+\_\+t}]{n}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_a7dd43d7414424c68563e14d0bda8e867}
Combine multiple Schnorr partial signatures. Returns\+: 1\+: the passed signatures were successfully combined. 0\+: the resulting signature is not valid (chance of 1 in 2$^\wedge$256) -\/1\+: some inputs were invalid, or the signatures were not created using the same set of nonces Args\+: ctx\+: pointer to a context object Out\+: sig64\+: pointer to a 64-\/byte array to place the combined signature (cannot be N\+U\+L\+L) In\+: sig64sin\+: pointer to an array of n pointers to 64-\/byte input signatures n\+: the number of signatures to combine (at least 1) 

Definition at line 157 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 2


\hypertarget{schnorr_2main__impl_8h_a6787237abf20a26c8c2fb195102ce810}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign@{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign}}
\index{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign@{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{unsigned char $\ast$}]{sig64, }
\item[{const unsigned char $\ast$}]{msg32, }
\item[{const unsigned char $\ast$}]{sec32, }
\item[{const {\bf secp256k1\+\_\+pubkey} $\ast$}]{pubnonce\+\_\+others, }
\item[{const unsigned char $\ast$}]{secnonce32}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_a6787237abf20a26c8c2fb195102ce810}
Produce a partial Schnorr signature, which can be combined using secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine, to end up with a full signature that is verifiable using secp256k1\+\_\+schnorr\+\_\+verify. Returns\+: 1\+: signature created successfully. 0\+: no valid signature exists with this combination of keys, nonces and message (chance around 1 in 2$^\wedge$128) -\/1\+: invalid private key, nonce, or public nonces. Args\+: ctx\+: pointer to context object, initialized for signing (cannot be N\+U\+L\+L) Out\+: sig64\+: pointer to 64-\/byte array to put partial signature in In\+: msg32\+: pointer to 32-\/byte message to sign sec32\+: pointer to 32-\/byte private key pubnonce\+\_\+others\+: pointer to pubkey containing the sum of the other\textquotesingle{}s nonces (see secp256k1\+\_\+ec\+\_\+pubkey\+\_\+combine) secnonce32\+: pointer to 32-\/byte array containing our nonce

The intended procedure for creating a multiparty signature is\+:
\begin{DoxyItemize}
\item Each signer S\mbox{[}i\mbox{]} with private key x\mbox{[}i\mbox{]} and public key Q\mbox{[}i\mbox{]} runs secp256k1\+\_\+schnorr\+\_\+generate\+\_\+nonce\+\_\+pair to produce a pair (k\mbox{[}i\mbox{]},R\mbox{[}i\mbox{]}) of private/public nonces.
\item All signers communicate their public nonces to each other (revealing your private nonce can lead to discovery of your private key, so it should be considered secret).
\item All signers combine all the public nonces they received (excluding their own) using secp256k1\+\_\+ec\+\_\+pubkey\+\_\+combine to obtain an Rall\mbox{[}i\mbox{]} = sum(R\mbox{[}0..i-\/1,i+1..n\mbox{]}).
\item All signers produce a partial signature using secp256k1\+\_\+schnorr\+\_\+partial\+\_\+sign, passing in their own private key x\mbox{[}i\mbox{]}, their own private nonce k\mbox{[}i\mbox{]}, and the sum of the others\textquotesingle{} public nonces Rall\mbox{[}i\mbox{]}.
\item All signers communicate their partial signatures to each other.
\item Someone combines all partial signatures using secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine, to obtain a full signature.
\item The resulting signature is validatable using secp256k1\+\_\+schnorr\+\_\+verify, with public key equal to the result of secp256k1\+\_\+ec\+\_\+pubkey\+\_\+combine of the signers\textquotesingle{} public keys (sum(Q\mbox{[}0..n\mbox{]})).

Note that secp256k1\+\_\+schnorr\+\_\+partial\+\_\+combine and secp256k1\+\_\+ec\+\_\+pubkey\+\_\+combine function take their arguments in any order, and it is possible to pre-\/combine several inputs already with one call, and add more inputs later by calling the function again (they are commutative and associative). 
\end{DoxyItemize}

Definition at line 133 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 3


\hypertarget{schnorr_2main__impl_8h_aa4480a44de97ffc056712ea9fd9631c5}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+recover@{secp256k1\+\_\+schnorr\+\_\+recover}}
\index{secp256k1\+\_\+schnorr\+\_\+recover@{secp256k1\+\_\+schnorr\+\_\+recover}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+recover}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+recover (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{{\bf secp256k1\+\_\+pubkey} $\ast$}]{pubkey, }
\item[{const unsigned char $\ast$}]{sig64, }
\item[{const unsigned char $\ast$}]{msg32}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_aa4480a44de97ffc056712ea9fd9631c5}
Recover an E\+C public key from a Schnorr signature created using secp256k1\+\_\+schnorr\+\_\+sign. Returns\+: 1\+: public key successfully recovered (which guarantees a correct signature). 0\+: otherwise. Args\+: ctx\+: pointer to a context object, initialized for verification (cannot be N\+U\+L\+L) Out\+: pubkey\+: pointer to a pubkey to set to the recovered public key (cannot be N\+U\+L\+L). In\+: sig64\+: signature as 64 byte array (cannot be N\+U\+L\+L) msg32\+: the 32-\/byte message hash assumed to be signed (cannot be N\+U\+L\+L) 

Definition at line 73 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 4


\hypertarget{schnorr_2main__impl_8h_a0d7ae4600f16da7c9464c80fefc72072}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+sign@{secp256k1\+\_\+schnorr\+\_\+sign}}
\index{secp256k1\+\_\+schnorr\+\_\+sign@{secp256k1\+\_\+schnorr\+\_\+sign}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+sign}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+sign (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{unsigned char $\ast$}]{sig64, }
\item[{const unsigned char $\ast$}]{msg32, }
\item[{const unsigned char $\ast$}]{seckey, }
\item[{{\bf secp256k1\+\_\+nonce\+\_\+function}}]{noncefp, }
\item[{const void $\ast$}]{ndata}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_a0d7ae4600f16da7c9464c80fefc72072}
Create a signature using a custom E\+C-\/\+Schnorr-\/\+S\+H\+A256 construction. It produces non-\/malleable 64-\/byte signatures which support public key recovery batch validation, and multiparty signing. Returns\+: 1\+: signature created 0\+: the nonce generation function failed, or the private key was invalid. Args\+: ctx\+: pointer to a context object, initialized for signing (cannot be N\+U\+L\+L) Out\+: sig64\+: pointer to a 64-\/byte array where the signature will be placed (cannot be N\+U\+L\+L) In\+: msg32\+: the 32-\/byte message hash being signed (cannot be N\+U\+L\+L) seckey\+: pointer to a 32-\/byte secret key (cannot be N\+U\+L\+L) noncefp\+:pointer to a nonce generation function. If N\+U\+L\+L, secp256k1\+\_\+nonce\+\_\+function\+\_\+default is used ndata\+: pointer to arbitrary data used by the nonce generation function (can be N\+U\+L\+L) 

Definition at line 23 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 5


\hypertarget{schnorr_2main__impl_8h_a5d23afb11115cb53171b34da09ff3ad0}{}\index{schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}!secp256k1\+\_\+schnorr\+\_\+verify@{secp256k1\+\_\+schnorr\+\_\+verify}}
\index{secp256k1\+\_\+schnorr\+\_\+verify@{secp256k1\+\_\+schnorr\+\_\+verify}!schnorr/main\+\_\+impl.\+h@{schnorr/main\+\_\+impl.\+h}}
\subsubsection[{secp256k1\+\_\+schnorr\+\_\+verify}]{\setlength{\rightskip}{0pt plus 5cm}int secp256k1\+\_\+schnorr\+\_\+verify (
\begin{DoxyParamCaption}
\item[{const {\bf secp256k1\+\_\+context} $\ast$}]{ctx, }
\item[{const unsigned char $\ast$}]{sig64, }
\item[{const unsigned char $\ast$}]{msg32, }
\item[{const {\bf secp256k1\+\_\+pubkey} $\ast$}]{pubkey}
\end{DoxyParamCaption}
)}\label{schnorr_2main__impl_8h_a5d23afb11115cb53171b34da09ff3ad0}
Verify a signature created by secp256k1\+\_\+schnorr\+\_\+sign. Returns\+: 1\+: correct signature 0\+: incorrect signature Args\+: ctx\+: a secp256k1 context object, initialized for verification. In\+: sig64\+: the 64-\/byte signature being verified (cannot be N\+U\+L\+L) msg32\+: the 32-\/byte message hash being verified (cannot be N\+U\+L\+L) pubkey\+: the public key to verify with (cannot be N\+U\+L\+L) 

Definition at line 61 of file main\+\_\+impl.\+h.



Here is the caller graph for this function\+:
% FIG 6


