.TH "/home/dev/ds-160209/src/lz4/lz4.c" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/dev/ds-160209/src/lz4/lz4.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'lz4\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB_PACKED\fP"
.br
.ti -1c
.RI "struct \fB_PACKED\fP"
.br
.ti -1c
.RI "struct \fB_PACKED\fP"
.br
.ti -1c
.RI "struct \fB_PACKED\fP"
.br
.ti -1c
.RI "struct \fBLZ4_Data_Structure\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMEMORY_USAGE\fP   14"
.br
.ti -1c
.RI "#define \fBHEAPMODE\fP   0"
.br
.ti -1c
.RI "#define \fBLZ4_ARCH64\fP   0"
.br
.ti -1c
.RI "#define \fBrestrict\fP   /* Disable restrict */"
.br
.ti -1c
.RI "#define \fBFORCE_INLINE\fP   static inline"
.br
.ti -1c
.RI "#define \fBlz4_bswap16\fP(x)   ((unsigned short int) ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8)))"
.br
.ti -1c
.RI "#define \fBGCC_VERSION\fP   (__GNUC__ * 100 + __GNUC_MINOR__)"
.br
.ti -1c
.RI "#define \fBexpect\fP(expr,  \fBvalue\fP)   (expr)"
.br
.ti -1c
.RI "#define \fBlikely\fP(expr)   \fBexpect\fP((expr) != 0, 1)"
.br
.ti -1c
.RI "#define \fBunlikely\fP(expr)   \fBexpect\fP((expr) != 0, 0)"
.br
.ti -1c
.RI "#define \fBALLOCATOR\fP(n,  s)   calloc(n,s)"
.br
.ti -1c
.RI "#define \fBFREEMEM\fP   free"
.br
.ti -1c
.RI "#define \fBMEM_INIT\fP   memset"
.br
.ti -1c
.RI "#define \fB_PACKED\fP"
.br
.ti -1c
.RI "#define \fBA16\fP(x)   (((U16_S *)(x))->v)"
.br
.ti -1c
.RI "#define \fBA32\fP(x)   (((U32_S *)(x))->v)"
.br
.ti -1c
.RI "#define \fBA64\fP(x)   (((U64_S *)(x))->v)"
.br
.ti -1c
.RI "#define \fBAARCH\fP(x)   (((size_t_S *)(x))->v)"
.br
.ti -1c
.RI "#define \fBLZ4_HASHLOG\fP   (\fBMEMORY_USAGE\fP-2)"
.br
.ti -1c
.RI "#define \fBHASHTABLESIZE\fP   (1 << \fBMEMORY_USAGE\fP)"
.br
.ti -1c
.RI "#define \fBHASHNBCELLS4\fP   (1 << \fBLZ4_HASHLOG\fP)"
.br
.ti -1c
.RI "#define \fBMINMATCH\fP   4"
.br
.ti -1c
.RI "#define \fBCOPYLENGTH\fP   8"
.br
.ti -1c
.RI "#define \fBLASTLITERALS\fP   5"
.br
.ti -1c
.RI "#define \fBMFLIMIT\fP   (\fBCOPYLENGTH\fP+\fBMINMATCH\fP)"
.br
.ti -1c
.RI "#define \fBKB\fP   *(1U<<10)"
.br
.ti -1c
.RI "#define \fBMB\fP   *(1U<<20)"
.br
.ti -1c
.RI "#define \fBGB\fP   *(1U<<30)"
.br
.ti -1c
.RI "#define \fBLZ4_64KLIMIT\fP   ((64 \fBKB\fP) + (\fBMFLIMIT\fP-1))"
.br
.ti -1c
.RI "#define \fBSKIPSTRENGTH\fP   6   /* Increasing this \fBvalue\fP will make the compression run slower on incompressible data */"
.br
.ti -1c
.RI "#define \fBMAXD_LOG\fP   16"
.br
.ti -1c
.RI "#define \fBMAX_DISTANCE\fP   ((1 << \fBMAXD_LOG\fP) - 1)"
.br
.ti -1c
.RI "#define \fBML_BITS\fP   4"
.br
.ti -1c
.RI "#define \fBML_MASK\fP   ((1U<<ML_BITS)-1)"
.br
.ti -1c
.RI "#define \fBRUN_BITS\fP   (8-\fBML_BITS\fP)"
.br
.ti -1c
.RI "#define \fBRUN_MASK\fP   ((1U<<RUN_BITS)-1)"
.br
.ti -1c
.RI "#define \fBSTEPSIZE\fP   sizeof(size_t)"
.br
.ti -1c
.RI "#define \fBLZ4_COPYSTEP\fP(d,  s)   { \fBAARCH\fP(d) = \fBAARCH\fP(s); d+=\fBSTEPSIZE\fP; s+=\fBSTEPSIZE\fP; }"
.br
.ti -1c
.RI "#define \fBLZ4_COPY8\fP(d,  s)   { \fBLZ4_COPYSTEP\fP(d,s); if (\fBSTEPSIZE\fP<8) \fBLZ4_COPYSTEP\fP(d,s); }"
.br
.ti -1c
.RI "#define \fBLZ4_READ_LITTLEENDIAN_16\fP(d,  s,  p)   { d = (s) - \fBA16\fP(p); }"
.br
.ti -1c
.RI "#define \fBLZ4_WRITE_LITTLEENDIAN_16\fP(p,  v)   { \fBA16\fP(p) = v; p+=2; }"
.br
.ti -1c
.RI "#define \fBLZ4_WILDCOPY\fP(d,  s,  e)   { do { \fBLZ4_COPY8\fP(d,s) } while (d<e); }           /* at the end, d>=e; */"
.br
.ti -1c
.RI "#define \fBLZ4_SECURECOPY\fP(d,  s,  e)   { if (d<e) \fBLZ4_WILDCOPY\fP(d,s,e); }"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned char \fBBYTE\fP"
.br
.ti -1c
.RI "typedef unsigned short \fBU16\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBU32\fP"
.br
.ti -1c
.RI "typedef signed int \fBS32\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBU64\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBlimitedOutput_directive\fP { \fBnotLimited\fP = 0, \fBlimited\fP = 1 }"
.br
.ti -1c
.RI "enum \fBtableType_t\fP { \fBbyPtr\fP, \fBbyU32\fP, \fBbyU16\fP }"
.br
.ti -1c
.RI "enum \fBprefix64k_directive\fP { \fBnoPrefix\fP = 0, \fBwithPrefix\fP = 1 }"
.br
.ti -1c
.RI "enum \fBendCondition_directive\fP { \fBendOnOutputSize\fP = 0, \fBendOnInputSize\fP = 1 }"
.br
.ti -1c
.RI "enum \fBearlyEnd_directive\fP { \fBfull\fP = 0, \fBpartial\fP = 1 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBFORCE_INLINE\fP int \fBLZ4_NbCommonBytes\fP (register \fBU32\fP val)"
.br
.ti -1c
.RI "int \fBLZ4_compressBound\fP (int isize)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP int \fBLZ4_hashSequence\fP (\fBU32\fP sequence, \fBtableType_t\fP tableType)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP int \fBLZ4_hashPosition\fP (const \fBBYTE\fP *p, \fBtableType_t\fP tableType)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP void \fBLZ4_putPositionOnHash\fP (const \fBBYTE\fP *p, \fBU32\fP h, void *tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP *srcBase)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP void \fBLZ4_putPosition\fP (const \fBBYTE\fP *p, void *tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP *srcBase)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP const \fBBYTE\fP * \fBLZ4_getPositionOnHash\fP (\fBU32\fP h, void *tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP *srcBase)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP const \fBBYTE\fP * \fBLZ4_getPosition\fP (const \fBBYTE\fP *p, void *tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP *srcBase)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP int \fBLZ4_compress_generic\fP (void *ctx, const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize, \fBlimitedOutput_directive\fP limitedOutput, \fBtableType_t\fP tableType, \fBprefix64k_directive\fP prefix)"
.br
.ti -1c
.RI "int \fBLZ4_compress\fP (const char *\fBsource\fP, char *dest, int inputSize)"
.br
.ti -1c
.RI "int \fBLZ4_compress_limitedOutput\fP (const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_sizeofState\fP ()"
.br
.ti -1c
.RI "int \fBLZ4_compress_withState\fP (void *\fBstate\fP, const char *\fBsource\fP, char *dest, int inputSize)"
.br
.ti -1c
.RI "int \fBLZ4_compress_limitedOutput_withState\fP (void *\fBstate\fP, const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_sizeofStreamState\fP ()"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP void \fBLZ4_init\fP (\fBLZ4_Data_Structure\fP *lz4ds, const \fBBYTE\fP *\fBbase\fP)"
.br
.ti -1c
.RI "int \fBLZ4_resetStreamState\fP (void *\fBstate\fP, const char *inputBuffer)"
.br
.ti -1c
.RI "void * \fBLZ4_create\fP (const char *inputBuffer)"
.br
.ti -1c
.RI "int \fBLZ4_free\fP (void *LZ4_Data)"
.br
.ti -1c
.RI "char * \fBLZ4_slideInputBuffer\fP (void *LZ4_Data)"
.br
.ti -1c
.RI "int \fBLZ4_compress_continue\fP (void *LZ4_Data, const char *\fBsource\fP, char *dest, int inputSize)"
.br
.ti -1c
.RI "int \fBLZ4_compress_limitedOutput_continue\fP (void *LZ4_Data, const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize)"
.br
.ti -1c
.RI "\fBFORCE_INLINE\fP int \fBLZ4_decompress_generic\fP (const char *\fBsource\fP, char *dest, int inputSize, int outputSize, int endOnInput, int prefix64k, int partialDecoding, int targetOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_decompress_safe\fP (const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_decompress_safe_withPrefix64k\fP (const char *\fBsource\fP, char *dest, int inputSize, int maxOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_decompress_safe_partial\fP (const char *\fBsource\fP, char *dest, int inputSize, int targetOutputSize, int maxOutputSize)"
.br
.ti -1c
.RI "int \fBLZ4_decompress_fast_withPrefix64k\fP (const char *\fBsource\fP, char *dest, int outputSize)"
.br
.ti -1c
.RI "int \fBLZ4_decompress_fast\fP (const char *\fBsource\fP, char *dest, int outputSize)"
.br
.ti -1c
.RI "int \fBLZ4_uncompress\fP (const char *\fBsource\fP, char *dest, int outputSize)"
.br
.ti -1c
.RI "int \fBLZ4_uncompress_unknownOutputSize\fP (const char *\fBsource\fP, char *dest, int isize, int maxOutputSize)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define \fB_PACKED\fP"

.PP
Definition at line 194 of file lz4\&.c\&.
.SS "#define A16(x)   (((U16_S *)(x))->v)"

.PP
Definition at line 218 of file lz4\&.c\&.
.SS "#define A32(x)   (((U32_S *)(x))->v)"

.PP
Definition at line 219 of file lz4\&.c\&.
.SS "#define A64(x)   (((U64_S *)(x))->v)"

.PP
Definition at line 220 of file lz4\&.c\&.
.SS "#define AARCH(x)   (((size_t_S *)(x))->v)"

.PP
Definition at line 221 of file lz4\&.c\&.
.SS "#define ALLOCATOR(n, s)   calloc(n,s)"

.PP
Definition at line 161 of file lz4\&.c\&.
.SS "#define COPYLENGTH   8"

.PP
Definition at line 233 of file lz4\&.c\&.
.SS "#define expect(expr, \fBvalue\fP)   (expr)"

.PP
Definition at line 150 of file lz4\&.c\&.
.SS "#define FORCE_INLINE   static inline"

.PP
Definition at line 135 of file lz4\&.c\&.
.SS "#define FREEMEM   free"

.PP
Definition at line 162 of file lz4\&.c\&.
.SS "#define GB   *(1U<<30)"

.PP
Definition at line 240 of file lz4\&.c\&.
.SS "#define GCC_VERSION   (__GNUC__ * 100 + __GNUC_MINOR__)"

.PP
Definition at line 145 of file lz4\&.c\&.
.SS "#define HASHNBCELLS4   (1 << \fBLZ4_HASHLOG\fP)"

.PP
Definition at line 229 of file lz4\&.c\&.
.SS "#define HASHTABLESIZE   (1 << \fBMEMORY_USAGE\fP)"

.PP
Definition at line 228 of file lz4\&.c\&.
.SS "#define HEAPMODE   0"

.PP
Definition at line 51 of file lz4\&.c\&.
.SS "#define KB   *(1U<<10)"

.PP
Definition at line 238 of file lz4\&.c\&.
.SS "#define LASTLITERALS   5"

.PP
Definition at line 234 of file lz4\&.c\&.
.SS "#define likely(expr)   \fBexpect\fP((expr) != 0, 1)"

.PP
Definition at line 153 of file lz4\&.c\&.
.SS "#define LZ4_64KLIMIT   ((64 \fBKB\fP) + (\fBMFLIMIT\fP-1))"

.PP
Definition at line 242 of file lz4\&.c\&.
.SS "#define LZ4_ARCH64   0"

.PP
Definition at line 64 of file lz4\&.c\&.
.SS "#define lz4_bswap16(x)   ((unsigned short int) ((((x) >> 8) & 0xffu) | (((x) & 0xffu) << 8)))"

.PP
Definition at line 142 of file lz4\&.c\&.
.SS "#define LZ4_COPY8(d, s)   { \fBLZ4_COPYSTEP\fP(d,s); if (\fBSTEPSIZE\fP<8) \fBLZ4_COPYSTEP\fP(d,s); }"

.PP
Definition at line 278 of file lz4\&.c\&.
.SS "#define LZ4_COPYSTEP(d, s)   { \fBAARCH\fP(d) = \fBAARCH\fP(s); d+=\fBSTEPSIZE\fP; s+=\fBSTEPSIZE\fP; }"

.PP
Definition at line 277 of file lz4\&.c\&.
.SS "#define LZ4_HASHLOG   (\fBMEMORY_USAGE\fP-2)"

.PP
Definition at line 227 of file lz4\&.c\&.
.SS "#define LZ4_READ_LITTLEENDIAN_16(d, s, p)   { d = (s) - \fBA16\fP(p); }"

.PP
Definition at line 284 of file lz4\&.c\&.
.SS "#define LZ4_SECURECOPY(d, s, e)   { if (d<e) \fBLZ4_WILDCOPY\fP(d,s,e); }"

.PP
Definition at line 297 of file lz4\&.c\&.
.SS "#define LZ4_WILDCOPY(d, s, e)   { do { \fBLZ4_COPY8\fP(d,s) } while (d<e); }           /* at the end, d>=e; */"

.PP
Definition at line 293 of file lz4\&.c\&.
.SS "#define LZ4_WRITE_LITTLEENDIAN_16(p, v)   { \fBA16\fP(p) = v; p+=2; }"

.PP
Definition at line 285 of file lz4\&.c\&.
.SS "#define MAX_DISTANCE   ((1 << \fBMAXD_LOG\fP) - 1)"

.PP
Definition at line 246 of file lz4\&.c\&.
.SS "#define MAXD_LOG   16"

.PP
Definition at line 245 of file lz4\&.c\&.
.SS "#define MB   *(1U<<20)"

.PP
Definition at line 239 of file lz4\&.c\&.
.SS "#define MEM_INIT   memset"

.PP
Definition at line 164 of file lz4\&.c\&.
.SS "#define MEMORY_USAGE   14"

.PP
Definition at line 44 of file lz4\&.c\&.
.SS "#define MFLIMIT   (\fBCOPYLENGTH\fP+\fBMINMATCH\fP)"

.PP
Definition at line 235 of file lz4\&.c\&.
.SS "#define MINMATCH   4"

.PP
Definition at line 231 of file lz4\&.c\&.
.SS "#define ML_BITS   4"

.PP
Definition at line 248 of file lz4\&.c\&.
.SS "#define ML_MASK   ((1U<<ML_BITS)-1)"

.PP
Definition at line 249 of file lz4\&.c\&.
.SS "#define restrict   /* Disable restrict */"

.PP
Definition at line 117 of file lz4\&.c\&.
.SS "#define RUN_BITS   (8-\fBML_BITS\fP)"

.PP
Definition at line 250 of file lz4\&.c\&.
.SS "#define RUN_MASK   ((1U<<RUN_BITS)-1)"

.PP
Definition at line 251 of file lz4\&.c\&.
.SS "#define SKIPSTRENGTH   6   /* Increasing this \fBvalue\fP will make the compression run slower on incompressible data */"

.PP
Definition at line 243 of file lz4\&.c\&.
.SS "#define STEPSIZE   sizeof(size_t)"

.PP
Definition at line 276 of file lz4\&.c\&.
.SS "#define unlikely(expr)   \fBexpect\fP((expr) != 0, 0)"

.PP
Definition at line 154 of file lz4\&.c\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef unsigned char \fBBYTE\fP"

.PP
Definition at line 184 of file lz4\&.c\&.
.SS "typedef signed int \fBS32\fP"

.PP
Definition at line 187 of file lz4\&.c\&.
.SS "typedef unsigned short \fBU16\fP"

.PP
Definition at line 185 of file lz4\&.c\&.
.SS "typedef unsigned int \fBU32\fP"

.PP
Definition at line 186 of file lz4\&.c\&.
.SS "typedef unsigned long long \fBU64\fP"

.PP
Definition at line 188 of file lz4\&.c\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBearlyEnd_directive\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIfull \fP\fP
.TP
\fB\fIpartial \fP\fP
.PP
Definition at line 270 of file lz4\&.c\&.
.SS "enum \fBendCondition_directive\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIendOnOutputSize \fP\fP
.TP
\fB\fIendOnInputSize \fP\fP
.PP
Definition at line 269 of file lz4\&.c\&.
.SS "enum \fBlimitedOutput_directive\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInotLimited \fP\fP
.TP
\fB\fIlimited \fP\fP
.PP
Definition at line 264 of file lz4\&.c\&.
.SS "enum \fBprefix64k_directive\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fInoPrefix \fP\fP
.TP
\fB\fIwithPrefix \fP\fP
.PP
Definition at line 267 of file lz4\&.c\&.
.SS "enum \fBtableType_t\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIbyPtr \fP\fP
.TP
\fB\fIbyU32 \fP\fP
.TP
\fB\fIbyU16 \fP\fP
.PP
Definition at line 265 of file lz4\&.c\&.
.SH "Function Documentation"
.PP 
.SS "int LZ4_compress (const char * source, char * dest, int inputSize)"

.PP
Definition at line 557 of file lz4\&.c\&.
.SS "int LZ4_compress_continue (void * LZ4_Data, const char * source, char * dest, int inputSize)"

.PP
Definition at line 699 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP int LZ4_compress_generic (void * ctx, const char * source, char * dest, int inputSize, int maxOutputSize, \fBlimitedOutput_directive\fP limitedOutput, \fBtableType_t\fP tableType, \fBprefix64k_directive\fP prefix)"

.PP
Definition at line 414 of file lz4\&.c\&.
.SS "int LZ4_compress_limitedOutput (const char * source, char * dest, int inputSize, int maxOutputSize)"

.PP
Definition at line 577 of file lz4\&.c\&.
.SS "int LZ4_compress_limitedOutput_continue (void * LZ4_Data, const char * source, char * dest, int inputSize, int maxOutputSize)"

.PP
Definition at line 705 of file lz4\&.c\&.
.SS "int LZ4_compress_limitedOutput_withState (void * state, const char * source, char * dest, int inputSize, int maxOutputSize)"

.PP
Definition at line 617 of file lz4\&.c\&.
.SS "int LZ4_compress_withState (void * state, const char * source, char * dest, int inputSize)"

.PP
Definition at line 605 of file lz4\&.c\&.
.SS "int LZ4_compressBound (int isize)"

.PP
Definition at line 372 of file lz4\&.c\&.
.SS "void* LZ4_create (const char * inputBuffer)"

.PP
Definition at line 653 of file lz4\&.c\&.
.SS "int LZ4_decompress_fast (const char * source, char * dest, int outputSize)"

.PP
Definition at line 870 of file lz4\&.c\&.
.SS "int LZ4_decompress_fast_withPrefix64k (const char * source, char * dest, int outputSize)"

.PP
Definition at line 865 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP int LZ4_decompress_generic (const char * source, char * dest, int inputSize, int outputSize, int endOnInput, int prefix64k, int partialDecoding, int targetOutputSize)"

.PP
Definition at line 720 of file lz4\&.c\&.
.SS "int LZ4_decompress_safe (const char * source, char * dest, int inputSize, int maxOutputSize)"

.PP
Definition at line 850 of file lz4\&.c\&.
.SS "int LZ4_decompress_safe_partial (const char * source, char * dest, int inputSize, int targetOutputSize, int maxOutputSize)"

.PP
Definition at line 860 of file lz4\&.c\&.
.SS "int LZ4_decompress_safe_withPrefix64k (const char * source, char * dest, int inputSize, int maxOutputSize)"

.PP
Definition at line 855 of file lz4\&.c\&.
.SS "int LZ4_free (void * LZ4_Data)"

.PP
Definition at line 661 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP const \fBBYTE\fP* LZ4_getPosition (const \fBBYTE\fP * p, void * tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP * srcBase)"

.PP
Definition at line 407 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP const \fBBYTE\fP* LZ4_getPositionOnHash (\fBU32\fP h, void * tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP * srcBase)"

.PP
Definition at line 400 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP int LZ4_hashPosition (const \fBBYTE\fP * p, \fBtableType_t\fP tableType)"

.PP
Definition at line 382 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP int LZ4_hashSequence (\fBU32\fP sequence, \fBtableType_t\fP tableType)"

.PP
Definition at line 374 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP void LZ4_init (\fBLZ4_Data_Structure\fP * lz4ds, const \fBBYTE\fP * base)"

.PP
Definition at line 638 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP int LZ4_NbCommonBytes (register \fBU32\fP val)"

.PP
Definition at line 337 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP void LZ4_putPosition (const \fBBYTE\fP * p, void * tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP * srcBase)"

.PP
Definition at line 394 of file lz4\&.c\&.
.SS "\fBFORCE_INLINE\fP void LZ4_putPositionOnHash (const \fBBYTE\fP * p, \fBU32\fP h, void * tableBase, \fBtableType_t\fP tableType, const \fBBYTE\fP * srcBase)"

.PP
Definition at line 384 of file lz4\&.c\&.
.SS "int LZ4_resetStreamState (void * state, const char * inputBuffer)"

.PP
Definition at line 646 of file lz4\&.c\&.
.SS "int LZ4_sizeofState (void)"

.PP
Definition at line 602 of file lz4\&.c\&.
.SS "int LZ4_sizeofStreamState (void)"

.PP
Definition at line 633 of file lz4\&.c\&.
.SS "char* LZ4_slideInputBuffer (void * LZ4_Data)"

.PP
Definition at line 668 of file lz4\&.c\&.
.SS "int LZ4_uncompress (const char * source, char * dest, int outputSize)"

.PP
Definition at line 879 of file lz4\&.c\&.
.SS "int LZ4_uncompress_unknownOutputSize (const char * source, char * dest, int isize, int maxOutputSize)"

.PP
Definition at line 880 of file lz4\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
