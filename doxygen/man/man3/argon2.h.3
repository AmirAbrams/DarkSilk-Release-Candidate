.TH "/home/dev/ds-160209/src/crypto/argon2/argon2.h" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/dev/ds-160209/src/crypto/argon2/argon2.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBArgon2_Context\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBARGON2_MIN_LANES\fP   UINT32_C(1)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_LANES\fP   UINT32_C(0xFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_THREADS\fP   UINT32_C(1)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_THREADS\fP   UINT32_C(0xFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_SYNC_POINTS\fP   UINT32_C(4)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_OUTLEN\fP   UINT32_C(4)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_OUTLEN\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_MEMORY\fP   (2 * \fBARGON2_SYNC_POINTS\fP) /* 2 blocks per slice */"
.br
.ti -1c
.RI "#define \fBARGON2_MIN\fP(a,  b)   ((a) < (b) ? (a) : (b))"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_MEMORY_BITS\fP   \fBARGON2_MIN\fP(UINT32_C(32), (sizeof(void *) * CHAR_BIT - 10 - 1))"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_MEMORY\fP   \fBARGON2_MIN\fP(UINT32_C(0xFFFFFFFF), UINT64_C(1) << ARGON2_MAX_MEMORY_BITS)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_TIME\fP   UINT32_C(1)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_TIME\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_PWD_LENGTH\fP   UINT32_C(0)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_PWD_LENGTH\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_AD_LENGTH\fP   UINT32_C(0)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_AD_LENGTH\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_SALT_LENGTH\fP   UINT32_C(8)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_SALT_LENGTH\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_MIN_SECRET\fP   UINT32_C(0)"
.br
.ti -1c
.RI "#define \fBARGON2_MAX_SECRET\fP   UINT32_C(0xFFFFFFFF)"
.br
.ti -1c
.RI "#define \fBARGON2_FLAG_CLEAR_PASSWORD\fP   (UINT32_C(1) << 0)"
.br
.ti -1c
.RI "#define \fBARGON2_FLAG_CLEAR_SECRET\fP   (UINT32_C(1) << 1)"
.br
.ti -1c
.RI "#define \fBARGON2_FLAG_CLEAR_MEMORY\fP   (UINT32_C(1) << 2)"
.br
.ti -1c
.RI "#define \fBARGON2_DEFAULT_FLAGS\fP   (\fBARGON2_FLAG_CLEAR_MEMORY\fP)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBArgon2_ErrorCodes\fP \fBargon2_error_codes\fP"
.br
.ti -1c
.RI "typedef int(* \fBallocate_fptr\fP) (\fBuint8_t\fP **memory, size_t bytes_to_allocate)"
.br
.ti -1c
.RI "typedef void(* \fBdeallocate_fptr\fP) (\fBuint8_t\fP *memory, size_t bytes_to_allocate)"
.br
.ti -1c
.RI "typedef struct \fBArgon2_Context\fP \fBargon2_context\fP"
.br
.ti -1c
.RI "typedef enum \fBArgon2_type\fP \fBargon2_type\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBArgon2_ErrorCodes\fP { \fBARGON2_OK\fP = 0, \fBARGON2_OUTPUT_PTR_NULL\fP = 1, \fBARGON2_OUTPUT_TOO_SHORT\fP = 2, \fBARGON2_OUTPUT_TOO_LONG\fP = 3, \fBARGON2_PWD_TOO_SHORT\fP = 4, \fBARGON2_PWD_TOO_LONG\fP = 5, \fBARGON2_SALT_TOO_SHORT\fP = 6, \fBARGON2_SALT_TOO_LONG\fP = 7, \fBARGON2_AD_TOO_SHORT\fP = 8, \fBARGON2_AD_TOO_LONG\fP = 9, \fBARGON2_SECRET_TOO_SHORT\fP = 10, \fBARGON2_SECRET_TOO_LONG\fP = 11, \fBARGON2_TIME_TOO_SMALL\fP = 12, \fBARGON2_TIME_TOO_LARGE\fP = 13, \fBARGON2_MEMORY_TOO_LITTLE\fP = 14, \fBARGON2_MEMORY_TOO_MUCH\fP = 15, \fBARGON2_LANES_TOO_FEW\fP = 16, \fBARGON2_LANES_TOO_MANY\fP = 17, \fBARGON2_PWD_PTR_MISMATCH\fP = 18, \fBARGON2_SALT_PTR_MISMATCH\fP = 19, \fBARGON2_SECRET_PTR_MISMATCH\fP = 20, \fBARGON2_AD_PTR_MISMATCH\fP = 21, \fBARGON2_MEMORY_ALLOCATION_ERROR\fP = 22, \fBARGON2_FREE_MEMORY_CBK_NULL\fP = 23, \fBARGON2_ALLOCATE_MEMORY_CBK_NULL\fP = 24, \fBARGON2_INCORRECT_PARAMETER\fP = 25, \fBARGON2_INCORRECT_TYPE\fP = 26, \fBARGON2_OUT_PTR_MISMATCH\fP = 27, \fBARGON2_THREADS_TOO_FEW\fP = 28, \fBARGON2_THREADS_TOO_MANY\fP = 29, \fBARGON2_MISSING_ARGS\fP = 30, \fBARGON2_ENCODING_FAIL\fP = 31, \fBARGON2_DECODING_FAIL\fP = 32, \fBARGON2_THREAD_FAIL\fP = 33, \fBARGON2_ERROR_CODES_LENGTH\fP }"
.br
.ti -1c
.RI "enum \fBArgon2_type\fP { \fBArgon2_d\fP = 0, \fBArgon2_i\fP = 1 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBargon2_core\fP (\fBargon2_context\fP *context, \fBargon2_type\fP type)"
.br
.ti -1c
.RI "int \fBargon2i_hash_encoded\fP (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void *pwd, const size_t pwdlen, const void *salt, const size_t saltlen, const size_t hashlen, char *encoded, const size_t encodedlen)"
.br
.ti -1c
.RI "int \fBargon2i_hash_raw\fP (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void *pwd, const size_t pwdlen, const void *salt, const size_t saltlen, void *\fBhash\fP, const size_t hashlen)"
.br
.ti -1c
.RI "int \fBargon2d_hash_encoded\fP (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void *pwd, const size_t pwdlen, const void *salt, const size_t saltlen, const size_t hashlen, char *encoded, const size_t encodedlen)"
.br
.ti -1c
.RI "int \fBargon2d_hash_raw\fP (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void *pwd, const size_t pwdlen, const void *salt, const size_t saltlen, void *\fBhash\fP, const size_t hashlen)"
.br
.ti -1c
.RI "int \fBargon2_hash\fP (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void *pwd, const size_t pwdlen, const void *salt, const size_t saltlen, void *\fBhash\fP, const size_t hashlen, char *encoded, const size_t encodedlen, \fBargon2_type\fP type)"
.br
.ti -1c
.RI "int \fBargon2i_verify\fP (const char *encoded, const void *pwd, const size_t pwdlen)"
.br
.ti -1c
.RI "int \fBargon2d_verify\fP (const char *encoded, const void *pwd, const size_t pwdlen)"
.br
.ti -1c
.RI "int \fBargon2_verify\fP (const char *encoded, const void *pwd, const size_t pwdlen, \fBargon2_type\fP type)"
.br
.ti -1c
.RI "int \fBargon2d\fP (\fBargon2_context\fP *context)"
.br
.ti -1c
.RI "int \fBargon2i\fP (\fBargon2_context\fP *context)"
.br
.ti -1c
.RI "int \fBargon2di\fP (\fBargon2_context\fP *context)"
.br
.ti -1c
.RI "int \fBargon2ds\fP (\fBargon2_context\fP *context)"
.br
.ti -1c
.RI "int \fBargon2id\fP (\fBargon2_context\fP *context)"
.br
.ti -1c
.RI "int \fBverify_d\fP (\fBargon2_context\fP *context, const char *\fBhash\fP)"
.br
.ti -1c
.RI "int \fBverify_i\fP (\fBargon2_context\fP *context, const char *\fBhash\fP)"
.br
.ti -1c
.RI "const char * \fBerror_message\fP (int error_code)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ARGON2_DEFAULT_FLAGS   (\fBARGON2_FLAG_CLEAR_MEMORY\fP)"

.PP
Definition at line 76 of file argon2\&.h\&.
.SS "#define ARGON2_FLAG_CLEAR_MEMORY   (UINT32_C(1) << 2)"

.PP
Definition at line 75 of file argon2\&.h\&.
.SS "#define ARGON2_FLAG_CLEAR_PASSWORD   (UINT32_C(1) << 0)"

.PP
Definition at line 73 of file argon2\&.h\&.
.SS "#define ARGON2_FLAG_CLEAR_SECRET   (UINT32_C(1) << 1)"

.PP
Definition at line 74 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_AD_LENGTH   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 63 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_LANES   UINT32_C(0xFFFFFF)"

.PP
Definition at line 29 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_MEMORY   \fBARGON2_MIN\fP(UINT32_C(0xFFFFFFFF), UINT64_C(1) << ARGON2_MAX_MEMORY_BITS)"

.PP
Definition at line 50 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_MEMORY_BITS   \fBARGON2_MIN\fP(UINT32_C(32), (sizeof(void *) * CHAR_BIT - 10 - 1))"

.PP
Definition at line 48 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_OUTLEN   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 40 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_PWD_LENGTH   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 59 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_SALT_LENGTH   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 67 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_SECRET   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 71 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_THREADS   UINT32_C(0xFFFFFF)"

.PP
Definition at line 33 of file argon2\&.h\&.
.SS "#define ARGON2_MAX_TIME   UINT32_C(0xFFFFFFFF)"

.PP
Definition at line 55 of file argon2\&.h\&.
.SS "#define ARGON2_MIN(a, b)   ((a) < (b) ? (a) : (b))"

.PP
Definition at line 45 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_AD_LENGTH   UINT32_C(0)"

.PP
Definition at line 62 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_LANES   UINT32_C(1)"

.PP
Definition at line 28 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_MEMORY   (2 * \fBARGON2_SYNC_POINTS\fP) /* 2 blocks per slice */"

.PP
Definition at line 43 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_OUTLEN   UINT32_C(4)"

.PP
Definition at line 39 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_PWD_LENGTH   UINT32_C(0)"

.PP
Definition at line 58 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_SALT_LENGTH   UINT32_C(8)"

.PP
Definition at line 66 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_SECRET   UINT32_C(0)"

.PP
Definition at line 70 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_THREADS   UINT32_C(1)"

.PP
Definition at line 32 of file argon2\&.h\&.
.SS "#define ARGON2_MIN_TIME   UINT32_C(1)"

.PP
Definition at line 54 of file argon2\&.h\&.
.SS "#define ARGON2_SYNC_POINTS   UINT32_C(4)"

.PP
Definition at line 36 of file argon2\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef int(* allocate_fptr) (\fBuint8_t\fP **memory, size_t bytes_to_allocate)"

.PP
Definition at line 140 of file argon2\&.h\&.
.SS "typedef struct \fBArgon2_Context\fP  \fBargon2_context\fP"

.SS "typedef enum \fBArgon2_ErrorCodes\fP  \fBargon2_error_codes\fP"

.SS "typedef enum \fBArgon2_type\fP  \fBargon2_type\fP"

.SS "typedef void(* deallocate_fptr) (\fBuint8_t\fP *memory, size_t bytes_to_allocate)"

.PP
Definition at line 141 of file argon2\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBArgon2_ErrorCodes\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIARGON2_OK \fP\fP
.TP
\fB\fIARGON2_OUTPUT_PTR_NULL \fP\fP
.TP
\fB\fIARGON2_OUTPUT_TOO_SHORT \fP\fP
.TP
\fB\fIARGON2_OUTPUT_TOO_LONG \fP\fP
.TP
\fB\fIARGON2_PWD_TOO_SHORT \fP\fP
.TP
\fB\fIARGON2_PWD_TOO_LONG \fP\fP
.TP
\fB\fIARGON2_SALT_TOO_SHORT \fP\fP
.TP
\fB\fIARGON2_SALT_TOO_LONG \fP\fP
.TP
\fB\fIARGON2_AD_TOO_SHORT \fP\fP
.TP
\fB\fIARGON2_AD_TOO_LONG \fP\fP
.TP
\fB\fIARGON2_SECRET_TOO_SHORT \fP\fP
.TP
\fB\fIARGON2_SECRET_TOO_LONG \fP\fP
.TP
\fB\fIARGON2_TIME_TOO_SMALL \fP\fP
.TP
\fB\fIARGON2_TIME_TOO_LARGE \fP\fP
.TP
\fB\fIARGON2_MEMORY_TOO_LITTLE \fP\fP
.TP
\fB\fIARGON2_MEMORY_TOO_MUCH \fP\fP
.TP
\fB\fIARGON2_LANES_TOO_FEW \fP\fP
.TP
\fB\fIARGON2_LANES_TOO_MANY \fP\fP
.TP
\fB\fIARGON2_PWD_PTR_MISMATCH \fP\fP
.TP
\fB\fIARGON2_SALT_PTR_MISMATCH \fP\fP
.TP
\fB\fIARGON2_SECRET_PTR_MISMATCH \fP\fP
.TP
\fB\fIARGON2_AD_PTR_MISMATCH \fP\fP
.TP
\fB\fIARGON2_MEMORY_ALLOCATION_ERROR \fP\fP
.TP
\fB\fIARGON2_FREE_MEMORY_CBK_NULL \fP\fP
.TP
\fB\fIARGON2_ALLOCATE_MEMORY_CBK_NULL \fP\fP
.TP
\fB\fIARGON2_INCORRECT_PARAMETER \fP\fP
.TP
\fB\fIARGON2_INCORRECT_TYPE \fP\fP
.TP
\fB\fIARGON2_OUT_PTR_MISMATCH \fP\fP
.TP
\fB\fIARGON2_THREADS_TOO_FEW \fP\fP
.TP
\fB\fIARGON2_THREADS_TOO_MANY \fP\fP
.TP
\fB\fIARGON2_MISSING_ARGS \fP\fP
.TP
\fB\fIARGON2_ENCODING_FAIL \fP\fP
.TP
\fB\fIARGON2_DECODING_FAIL \fP\fP
.TP
\fB\fIARGON2_THREAD_FAIL \fP\fP
.TP
\fB\fIARGON2_ERROR_CODES_LENGTH \fP\fP
.PP
Definition at line 79 of file argon2\&.h\&.
.SS "enum \fBArgon2_type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIArgon2_d \fP\fP
.TP
\fB\fIArgon2_i \fP\fP
.PP
Definition at line 197 of file argon2\&.h\&.
.SH "Function Documentation"
.PP 
.SS "int argon2_core (\fBargon2_context\fP * context, \fBargon2_type\fP type)"

.PP
Definition at line 109 of file argon2\&.c\&.
.SS "int argon2_hash (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void * pwd, const size_t pwdlen, const void * salt, const size_t saltlen, void * hash, const size_t hashlen, char * encoded, const size_t encodedlen, \fBargon2_type\fP type)"

.PP
Definition at line 166 of file argon2\&.c\&.
.SS "int argon2_verify (const char * encoded, const void * pwd, const size_t pwdlen, \fBargon2_type\fP type)"

.PP
Definition at line 289 of file argon2\&.c\&.
.SS "int argon2d (\fBargon2_context\fP * context)"

.PP
Definition at line 353 of file argon2\&.c\&.
.SS "int argon2d_hash_encoded (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void * pwd, const size_t pwdlen, const void * salt, const size_t saltlen, const size_t hashlen, char * encoded, const size_t encodedlen)"

.PP
Definition at line 260 of file argon2\&.c\&.
.SS "int argon2d_hash_raw (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void * pwd, const size_t pwdlen, const void * salt, const size_t saltlen, void * hash, const size_t hashlen)"

.PP
Definition at line 270 of file argon2\&.c\&.
.SS "int argon2d_verify (const char * encoded, const void * pwd, const size_t pwdlen)"

.PP
Definition at line 348 of file argon2\&.c\&.
.SS "int argon2di (\fBargon2_context\fP * context)"

.SS "int argon2ds (\fBargon2_context\fP * context)"

.SS "int argon2i (\fBargon2_context\fP * context)"

.PP
Definition at line 355 of file argon2\&.c\&.
.SS "int argon2i_hash_encoded (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void * pwd, const size_t pwdlen, const void * salt, const size_t saltlen, const size_t hashlen, char * encoded, const size_t encodedlen)"
Hashes a password with Argon2i, producing an encoded hash 
.PP
\fBParameters:\fP
.RS 4
\fIt_cost\fP Number of iterations 
.br
\fIm_cost\fP Sets memory usage to m_cost kibibytes 
.br
\fIparallelism\fP Number of threads and compute lanes 
.br
\fIpwd\fP Pointer to password 
.br
\fIpwdlen\fP Password size in bytes 
.br
\fIsalt\fP Pointer to salt 
.br
\fIsaltlen\fP Salt size in bytes 
.br
\fIhashlen\fP Desired length of the hash in bytes 
.br
\fIencoded\fP Buffer where to write the encoded hash 
.br
\fIencodedlen\fP Size of the buffer (thus max size of the encoded hash) 
.RE
.PP
\fBPrecondition:\fP
.RS 4
Different parallelism levels will give different results 
.PP
Returns ARGON2_OK if successful 
.RE
.PP

.PP
Definition at line 241 of file argon2\&.c\&.
.SS "int argon2i_hash_raw (const \fBuint32_t\fP t_cost, const \fBuint32_t\fP m_cost, const \fBuint32_t\fP parallelism, const void * pwd, const size_t pwdlen, const void * salt, const size_t saltlen, void * hash, const size_t hashlen)"
Hashes a password with Argon2i, producing a raw hash 
.PP
\fBParameters:\fP
.RS 4
\fIt_cost\fP Number of iterations 
.br
\fIm_cost\fP Sets memory usage to m_cost kibibytes 
.br
\fIparallelism\fP Number of threads and compute lanes 
.br
\fIpwd\fP Pointer to password 
.br
\fIpwdlen\fP Password size in bytes 
.br
\fIsalt\fP Pointer to salt 
.br
\fIsaltlen\fP Salt size in bytes 
.br
\fIhash\fP Buffer where to write the raw hash 
.br
\fIhashlen\fP Desired length of the hash in bytes 
.RE
.PP
\fBPrecondition:\fP
.RS 4
Different parallelism levels will give different results 
.PP
Returns ARGON2_OK if successful 
.RE
.PP

.PP
Definition at line 251 of file argon2\&.c\&.
.SS "int argon2i_verify (const char * encoded, const void * pwd, const size_t pwdlen)"
Verifies a password against an encoded string 
.PP
\fBParameters:\fP
.RS 4
\fIencoded\fP String encoding parameters, salt, hash 
.br
\fIpwd\fP Pointer to password 
.RE
.PP
\fBPrecondition:\fP
.RS 4
Returns ARGON2_OK if successful 
.RE
.PP

.PP
Definition at line 343 of file argon2\&.c\&.
.SS "int argon2id (\fBargon2_context\fP * context)"

.SS "const char* error_message (int error_code)"

.PP
Definition at line 388 of file argon2\&.c\&.
.SS "int verify_d (\fBargon2_context\fP * context, const char * hash)"

.PP
Definition at line 357 of file argon2\&.c\&.
.SS "int verify_i (\fBargon2_context\fP * context, const char * hash)"

.PP
Definition at line 372 of file argon2\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
