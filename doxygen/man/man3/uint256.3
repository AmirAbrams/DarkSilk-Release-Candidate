.TH "uint256" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
uint256 \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <uint256\&.h>\fP
.PP
Inherits \fBbase_uint< 256 >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBuint256\fP ()"
.br
.ti -1c
.RI "\fBuint256\fP (const \fBbase_uint\fP< 256 > &b)"
.br
.ti -1c
.RI "\fBuint256\fP (\fBuint64_t\fP b)"
.br
.ti -1c
.RI "\fBuint256\fP (const std::string &str)"
.br
.ti -1c
.RI "\fBuint256\fP (const std::vector< unsigned char > &vch)"
.br
.ti -1c
.RI "\fBuint256\fP & \fBSetCompact\fP (\fBuint32_t\fP nCompact, bool *pfNegative=NULL, bool *pfOverflow=NULL)"
.br
.ti -1c
.RI "\fBuint32_t\fP \fBGetCompact\fP (bool fNegative=false) const "
.br
.ti -1c
.RI "\fBuint64_t\fP \fBGetHash\fP (const \fBuint256\fP &salt) const "
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
256-bit unsigned big integer\&. 
.PP
Definition at line 315 of file uint256\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "uint256::uint256 ()\fC [inline]\fP"

.PP
Definition at line 317 of file uint256\&.h\&.
.SS "uint256::uint256 (const \fBbase_uint\fP< 256 > & b)\fC [inline]\fP"

.PP
Definition at line 318 of file uint256\&.h\&.
.SS "uint256::uint256 (\fBuint64_t\fP b)\fC [inline]\fP"

.PP
Definition at line 319 of file uint256\&.h\&.
.SS "uint256::uint256 (const std::string & str)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 320 of file uint256\&.h\&.
.SS "uint256::uint256 (const std::vector< unsigned char > & vch)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 321 of file uint256\&.h\&.
.SH "Member Function Documentation"
.PP 
.SS "\fBuint32_t\fP uint256::GetCompact (bool fNegative = \fCfalse\fP) const"

.PP
Definition at line 274 of file uint256\&.cpp\&.
.SS "\fBuint64_t\fP uint256::GetHash (const \fBuint256\fP & salt) const"

.PP
Definition at line 339 of file uint256\&.cpp\&.
.SS "\fBuint256\fP & uint256::SetCompact (\fBuint32_t\fP nCompact, bool * pfNegative = \fCNULL\fP, bool * pfOverflow = \fCNULL\fP)"
The 'compact' format is a representation of a whole number N using an unsigned 32bit number similar to a floating point format\&. The most significant 8 bits are the unsigned exponent of base 256\&. This exponent can be thought of as 'number of bytes of N'\&. The lower 23 bits are the mantissa\&. Bit number 24 (0x800000) represents the sign of N\&. N = (-1^sign) * mantissa * 256^(exponent-3)
.PP
Satoshi's original implementation used BN_bn2mpi() and BN_mpi2bn()\&. MPI uses the most significant bit of the first byte as sign\&. Thus 0x1234560000 is compact (0x05123456) and 0xc0de000000 is compact (0x0600c0de)
.PP
Bitcoin only uses this 'compact' format for encoding difficulty targets, which are unsigned 256bit quantities\&. Thus, all the complexities of the sign bit and using base 256 are probably an implementation accident\&. 
.PP
Definition at line 254 of file uint256\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
