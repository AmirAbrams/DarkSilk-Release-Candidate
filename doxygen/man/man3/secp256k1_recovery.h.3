.TH "/home/dev/ds-160209/src/secp256k1/include/secp256k1_recovery.h" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/dev/ds-160209/src/secp256k1/include/secp256k1_recovery.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'secp256k1\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBsecp256k1_ecdsa_recoverable_signature\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_parse_compact\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *input64, int recid) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_convert\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_signature\fP *sig, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sigin) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_recoverable_signature_serialize_compact\fP (const \fBsecp256k1_context\fP *ctx, unsigned char *output64, int *recid, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sig) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP int \fBsecp256k1_ecdsa_sign_recoverable\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *msg32, const unsigned char *seckey, \fBsecp256k1_nonce_function\fP noncefp, const void *ndata) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.ti -1c
.RI "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int \fBsecp256k1_ecdsa_recover\fP (const \fBsecp256k1_context\fP *ctx, \fBsecp256k1_pubkey\fP *pubkey, const \fBsecp256k1_ecdsa_recoverable_signature\fP *sig, const unsigned char *msg32) \fBSECP256K1_ARG_NONNULL\fP(1) \fBSECP256K1_ARG_NONNULL\fP(2) \fBSECP256K1_ARG_NONNULL\fP(3) \fBSECP256K1_ARG_NONNULL\fP(4)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBSECP256K1_API\fP \fBSECP256K1_WARN_UNUSED_RESULT\fP int secp256k1_ecdsa_recover (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_pubkey\fP * pubkey, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * msg32)"
Recover an ECDSA public key from a signature\&.
.PP
Returns: 1: public key successfully recovered (which guarantees a correct signature)\&. 0: otherwise\&. Args: ctx: pointer to a context object, initialized for verification (cannot be NULL) Out: pubkey: pointer to the recovered public key (cannot be NULL) In: sig: pointer to initialized signature that supports pubkey recovery (cannot be NULL) msg32: the 32-byte message hash assumed to be signed (cannot be NULL) 
.PP
Definition at line 170 of file main_impl\&.h\&.
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_convert (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_signature\fP * sig, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sigin)"
Convert a recoverable signature into a normal signature\&.
.PP
Returns: 1 Out: sig: a pointer to a normal signature (cannot be NULL)\&. In: sigin: a pointer to a recoverable signature (cannot be NULL)\&. 
.PP
Definition at line 74 of file main_impl\&.h\&.
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_parse_compact (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * input64, int recid)"
Parse a compact ECDSA signature (64 bytes + recovery id)\&.
.PP
Returns: 1 when the signature could be parsed, 0 otherwise Args: ctx: a secp256k1 context object Out: sig: a pointer to a signature object In: input64: a pointer to a 64-byte compact signature recid: the recovery id (0, 1, 2 or 3) 
.PP
Definition at line 38 of file main_impl\&.h\&.
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_recoverable_signature_serialize_compact (const \fBsecp256k1_context\fP * ctx, unsigned char * output64, int * recid, const \fBsecp256k1_ecdsa_recoverable_signature\fP * sig)"
Serialize an ECDSA signature in compact format (64 bytes + recovery id)\&.
.PP
Returns: 1 Args: ctx: a secp256k1 context object Out: output64: a pointer to a 64-byte array of the compact signature (cannot be NULL) recid: a pointer to an integer to hold the recovery id (can be NULL)\&. In: sig: a pointer to an initialized signature object (cannot be NULL) 
.PP
Definition at line 60 of file main_impl\&.h\&.
.SS "\fBSECP256K1_API\fP int secp256k1_ecdsa_sign_recoverable (const \fBsecp256k1_context\fP * ctx, \fBsecp256k1_ecdsa_recoverable_signature\fP * sig, const unsigned char * msg32, const unsigned char * seckey, \fBsecp256k1_nonce_function\fP noncefp, const void * ndata)"
Create a recoverable ECDSA signature\&.
.PP
Returns: 1: signature created 0: the nonce generation function failed, or the private key was invalid\&. Args: ctx: pointer to a context object, initialized for signing (cannot be NULL) Out: sig: pointer to an array where the signature will be placed (cannot be NULL) In: msg32: the 32-byte message hash being signed (cannot be NULL) seckey: pointer to a 32-byte secret key (cannot be NULL) noncefp:pointer to a nonce generation function\&. If NULL, secp256k1_nonce_function_default is used ndata: pointer to arbitrary data used by the nonce generation function (can be NULL) 
.PP
Definition at line 123 of file main_impl\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
