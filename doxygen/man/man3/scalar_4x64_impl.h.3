.TH "/home/dev/ds-160209/src/secp256k1/src/scalar_4x64_impl.h" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/dev/ds-160209/src/secp256k1/src/scalar_4x64_impl.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSECP256K1_N_0\fP   ((\fBuint64_t\fP)0xBFD25E8CD0364141ULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_1\fP   ((\fBuint64_t\fP)0xBAAEDCE6AF48A03BULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_2\fP   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFEULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_3\fP   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFFULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_C_0\fP   (~\fBSECP256K1_N_0\fP + 1)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_C_1\fP   (~\fBSECP256K1_N_1\fP)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_C_2\fP   (1)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_H_0\fP   ((\fBuint64_t\fP)0xDFE92F46681B20A0ULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_H_1\fP   ((\fBuint64_t\fP)0x5D576E7357A4501DULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_H_2\fP   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFFULL)"
.br
.ti -1c
.RI "#define \fBSECP256K1_N_H_3\fP   ((\fBuint64_t\fP)0x7FFFFFFFFFFFFFFFULL)"
.br
.ti -1c
.RI "#define \fBmuladd\fP(a,  b)"
.br
.ti -1c
.RI "#define \fBmuladd_fast\fP(a,  b)"
.br
.ti -1c
.RI "#define \fBmuladd2\fP(a,  b)"
.br
.ti -1c
.RI "#define \fBsumadd\fP(a)"
.br
.ti -1c
.RI "#define \fBsumadd_fast\fP(a)"
.br
.ti -1c
.RI "#define \fBextract\fP(n)"
.br
.ti -1c
.RI "#define \fBextract_fast\fP(n)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define extract(n)"
\fBValue:\fP
.PP
.nf
{ \
    (n) = c0; \
    c0 = c1; \
    c1 = c2; \
    c2 = 0; \
}
.fi
Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits\&. 
.PP
Definition at line 255 of file scalar_4x64_impl\&.h\&.
.SS "#define extract_fast(n)"
\fBValue:\fP
.PP
.nf
{ \
    (n) = c0; \
    c0 = c1; \
    c1 = 0; \\
    VERIFY_CHECK(c2 == 0); \
}
.fi
Extract the lowest 64 bits of (c0,c1,c2) into n, and left shift the number 64 bits\&. c2 is required to be zero\&. 
.PP
Definition at line 263 of file scalar_4x64_impl\&.h\&.
.SS "#define muladd(a, b)"
\fBValue:\fP
.PP
.nf
{ \\
    uint64_t tl, th; \
    { \
        uint128_t t = (uint128_t)a * b; \
        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \
        tl = t; \
    } \
    c0 += tl;                 /* overflow is handled on the next line */ \
    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \
    c1 += th;                 /* overflow is handled on the next line */ \
    c2 += (c1 < th) ? 1 : 0;  /* never overflows by contract (verified in the next line) */ \\
    VERIFY_CHECK((c1 >= th) || (c2 != 0)); \
}
.fi
Add a*b to the number defined by (c0,c1,c2)\&. c2 must never overflow\&. 
.PP
Definition at line 187 of file scalar_4x64_impl\&.h\&.
.SS "#define muladd2(a, b)"
\fBValue:\fP
.PP
.nf
{ \\
    uint64_t tl, th, th2, tl2; \
    { \
        uint128_t t = (uint128_t)a * b; \
        th = t >> 64;               /* at most 0xFFFFFFFFFFFFFFFE */ \
        tl = t; \
    } \
    th2 = th + th;                  /* at most 0xFFFFFFFFFFFFFFFE (in case th was 0x7FFFFFFFFFFFFFFF) */ \
    c2 += (th2 < th) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\
    VERIFY_CHECK((th2 >= th) || (c2 != 0)); \
    tl2 = tl + tl;                  /* at most 0xFFFFFFFFFFFFFFFE (in case the lowest 63 bits of tl were 0x7FFFFFFFFFFFFFFF) */ \
    th2 += (tl2 < tl) ? 1 : 0;      /* at most 0xFFFFFFFFFFFFFFFF */ \
    c0 += tl2;                      /* overflow is handled on the next line */ \
    th2 += (c0 < tl2) ? 1 : 0;      /* second overflow is handled on the next line */ \
    c2 += (c0 < tl2) & (th2 == 0);  /* never overflows by contract (verified the next line) */ \\
    VERIFY_CHECK((c0 >= tl2) || (th2 != 0) || (c2 != 0)); \
    c1 += th2;                      /* overflow is handled on the next line */ \
    c2 += (c1 < th2) ? 1 : 0;       /* never overflows by contract (verified the next line) */ \\
    VERIFY_CHECK((c1 >= th2) || (c2 != 0)); \
}
.fi
Add 2*a*b to the number defined by (c0,c1,c2)\&. c2 must never overflow\&. 
.PP
Definition at line 216 of file scalar_4x64_impl\&.h\&.
.SS "#define muladd_fast(a, b)"
\fBValue:\fP
.PP
.nf
{ \\
    uint64_t tl, th; \
    { \
        uint128_t t = (uint128_t)a * b; \
        th = t >> 64;         /* at most 0xFFFFFFFFFFFFFFFE */ \
        tl = t; \
    } \
    c0 += tl;                 /* overflow is handled on the next line */ \
    th += (c0 < tl) ? 1 : 0;  /* at most 0xFFFFFFFFFFFFFFFF */ \
    c1 += th;                 /* never overflows by contract (verified in the next line) */ \\
    VERIFY_CHECK(c1 >= th); \
}
.fi
Add a*b to the number defined by (c0,c1)\&. c1 must never overflow\&. 
.PP
Definition at line 202 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_0   ((\fBuint64_t\fP)0xBFD25E8CD0364141ULL)"

.PP
Definition at line 11 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_1   ((\fBuint64_t\fP)0xBAAEDCE6AF48A03BULL)"

.PP
Definition at line 12 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_2   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFEULL)"

.PP
Definition at line 13 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_3   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFFULL)"

.PP
Definition at line 14 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_C_0   (~\fBSECP256K1_N_0\fP + 1)"

.PP
Definition at line 17 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_C_1   (~\fBSECP256K1_N_1\fP)"

.PP
Definition at line 18 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_C_2   (1)"

.PP
Definition at line 19 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_H_0   ((\fBuint64_t\fP)0xDFE92F46681B20A0ULL)"

.PP
Definition at line 22 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_H_1   ((\fBuint64_t\fP)0x5D576E7357A4501DULL)"

.PP
Definition at line 23 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_H_2   ((\fBuint64_t\fP)0xFFFFFFFFFFFFFFFFULL)"

.PP
Definition at line 24 of file scalar_4x64_impl\&.h\&.
.SS "#define SECP256K1_N_H_3   ((\fBuint64_t\fP)0x7FFFFFFFFFFFFFFFULL)"

.PP
Definition at line 25 of file scalar_4x64_impl\&.h\&.
.SS "#define sumadd(a)"
\fBValue:\fP
.PP
.nf
{ \
    unsigned int over; \
    c0 += (a);                  /* overflow is handled on the next line */ \
    over = (c0 < (a)) ? 1 : 0; \
    c1 += over;                 /* overflow is handled on the next line */ \
    c2 += (c1 < over) ? 1 : 0;  /* never overflows by contract */ \
}
.fi
Add a to the number defined by (c0,c1,c2)\&. c2 must never overflow\&. 
.PP
Definition at line 238 of file scalar_4x64_impl\&.h\&.
.SS "#define sumadd_fast(a)"
\fBValue:\fP
.PP
.nf
{ \
    c0 += (a);                 /* overflow is handled on the next line */ \
    c1 += (c0 < (a)) ? 1 : 0;  /* never overflows by contract (verified the next line) */ \\
    VERIFY_CHECK((c1 != 0) | (c0 >= (a))); \\
    VERIFY_CHECK(c2 == 0); \
}
.fi
Add a to the number defined by (c0,c1)\&. c1 must never overflow, c2 must be zero\&. 
.PP
Definition at line 247 of file scalar_4x64_impl\&.h\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
