.TH "/home/dev/ds-160209/src/utilstrencodings.h" 3 "Wed Feb 10 2016" "Version 1.0.0.0" "darksilk" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/dev/ds-160209/src/utilstrencodings.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdint\&.h>\fP
.br
\fC#include <string>\fP
.br
\fC#include <vector>\fP
.br
\fC#include 'serialize\&.h'\fP
.br
\fC#include 'allocators\&.h'\fP
.br
\fC#include <boost/date_time/posix_time/posix_time\&.hpp>\fP
.br
\fC#include <openssl/bio\&.h>\fP
.br
\fC#include <openssl/evp\&.h>\fP
.br
\fC#include <openssl/buffer\&.h>\fP
.br
\fC#include <openssl/crypto\&.h>\fP
.br
\fC#include <openssl/rand\&.h>\fP
.br
\fC#include <openssl/bn\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBEGIN\fP(a)   ((char*)&(a))"
.br
.ti -1c
.RI "#define \fBEND\fP(a)   ((char*)&((&(a))[1]))"
.br
.ti -1c
.RI "#define \fBUBEGIN\fP(a)   ((unsigned char*)&(a))"
.br
.ti -1c
.RI "#define \fBUEND\fP(a)   ((unsigned char*)&((&(a))[1]))"
.br
.ti -1c
.RI "#define \fBARRAYLEN\fP(array)   (sizeof(array)/sizeof((array)[0]))"
.br
.ti -1c
.RI "#define \fBPAIRTYPE\fP(t1,  t2)   std::pair<t1, t2>"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "std::vector< unsigned char > \fBDecodeBase64\fP (const char *p, bool *pfInvalid=NULL)"
.br
.ti -1c
.RI "std::string \fBDecodeBase64\fP (const std::string &str)"
.br
.ti -1c
.RI "std::string \fBEncodeBase64\fP (const unsigned char *pch, size_t len)"
.br
.ti -1c
.RI "std::string \fBEncodeBase64\fP (const std::string &str)"
.br
.ti -1c
.RI "\fBSecureString\fP \fBDecodeBase64Secure\fP (const \fBSecureString\fP &input)"
.br
.ti -1c
.RI "\fBSecureString\fP \fBEncodeBase64Secure\fP (const \fBSecureString\fP &input)"
.br
.ti -1c
.RI "std::vector< unsigned char > \fBDecodeBase32\fP (const char *p, bool *pfInvalid=NULL)"
.br
.ti -1c
.RI "std::string \fBDecodeBase32\fP (const std::string &str)"
.br
.ti -1c
.RI "std::string \fBEncodeBase32\fP (const unsigned char *pch, size_t len)"
.br
.ti -1c
.RI "std::string \fBEncodeBase32\fP (const std::string &str)"
.br
.ti -1c
.RI "std::string \fBi64tostr\fP (\fBint64_t\fP n)"
.br
.ti -1c
.RI "std::string \fBitostr\fP (int n)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBatoi64\fP (const char *psz)"
.br
.ti -1c
.RI "\fBint64_t\fP \fBatoi64\fP (const std::string &str)"
.br
.ti -1c
.RI "int \fBatoi\fP (const std::string &str)"
.br
.ti -1c
.RI "bool \fBParseInt32\fP (const std::string &str, \fBint32_t\fP *out)"
.br
.ti -1c
.RI "std::string \fBFormatParagraph\fP (const std::string in, size_t width=79, size_t indent=0)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ARRAYLEN(array)   (sizeof(array)/sizeof((array)[0]))"

.PP
Definition at line 32 of file utilstrencodings\&.h\&.
.SS "#define BEGIN(a)   ((char*)&(a))"
Utilities for converting data from/to strings\&. 
.PP
Definition at line 28 of file utilstrencodings\&.h\&.
.SS "#define END(a)   ((char*)&((&(a))[1]))"

.PP
Definition at line 29 of file utilstrencodings\&.h\&.
.SS "#define PAIRTYPE(t1, t2)   std::pair<t1, t2>"
This is needed because the foreach macro can't get over the comma in pair<t1, t2> 
.PP
Definition at line 35 of file utilstrencodings\&.h\&.
.SS "#define UBEGIN(a)   ((unsigned char*)&(a))"

.PP
Definition at line 30 of file utilstrencodings\&.h\&.
.SS "#define UEND(a)   ((unsigned char*)&((&(a))[1]))"

.PP
Definition at line 31 of file utilstrencodings\&.h\&.
.SH "Function Documentation"
.PP 
.SS "int atoi (const std::string & str)\fC [inline]\fP"

.PP
Definition at line 315 of file util\&.h\&.
.SS "\fBint64_t\fP atoi64 (const char * psz)\fC [inline]\fP"

.PP
Definition at line 297 of file util\&.h\&.
.SS "\fBint64_t\fP atoi64 (const std::string & str)\fC [inline]\fP"

.PP
Definition at line 306 of file util\&.h\&.
.SS "std::vector<unsigned char> DecodeBase32 (const char * p, bool * pfInvalid = \fCNULL\fP)"

.PP
Definition at line 839 of file util\&.cpp\&.
.SS "std::string DecodeBase32 (const std::string & str)"

.SS "std::vector<unsigned char> DecodeBase64 (const char * p, bool * pfInvalid = \fCNULL\fP)"

.PP
Definition at line 629 of file util\&.cpp\&.
.SS "std::string DecodeBase64 (const std::string & str)"

.SS "\fBSecureString\fP DecodeBase64Secure (const \fBSecureString\fP & input)"

.PP
Definition at line 746 of file util\&.cpp\&.
.SS "std::string EncodeBase32 (const unsigned char * pch, size_t len)"

.PP
Definition at line 775 of file util\&.cpp\&.
.SS "std::string EncodeBase32 (const std::string & str)"

.SS "std::string EncodeBase64 (const unsigned char * pch, size_t len)"

.PP
Definition at line 578 of file util\&.cpp\&.
.SS "std::string EncodeBase64 (const std::string & str)"

.SS "\fBSecureString\fP EncodeBase64Secure (const \fBSecureString\fP & input)"

.PP
Definition at line 719 of file util\&.cpp\&.
.SS "std::string FormatParagraph (const std::string in, size_t width = \fC79\fP, size_t indent = \fC0\fP)"
Format a paragraph of text to a fixed width, adding spaces for indentation to any added line\&. 
.PP
Definition at line 1007 of file util\&.cpp\&.
.SS "std::string i64tostr (\fBint64_t\fP n)\fC [inline]\fP"

.PP
Definition at line 287 of file util\&.h\&.
.SS "std::string itostr (int n)\fC [inline]\fP"

.PP
Definition at line 292 of file util\&.h\&.
.SS "bool ParseInt32 (const std::string & str, \fBint32_t\fP * out)"
Convert string to signed 32-bit integer with strict parse error feedback\&. 
.PP
\fBReturns:\fP
.RS 4
true if the entire string could be parsed as valid integer, false if not the entire string could be parsed or when overflow or underflow occurred\&. 
.RE
.PP

.PP
Definition at line 993 of file util\&.cpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for darksilk from the source code\&.
