<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.9.1">
  <compounddef id="schnorr__impl_8h" kind="file" language="C++">
    <compoundname>schnorr_impl.h</compoundname>
    <includes local="no">string.h</includes>
    <includes refid="schnorr_8h" local="yes">schnorr.h</includes>
    <includes refid="num_8h" local="yes">num.h</includes>
    <includes refid="field_8h" local="yes">field.h</includes>
    <includes refid="group_8h" local="yes">group.h</includes>
    <includes refid="ecmult_8h" local="yes">ecmult.h</includes>
    <includes refid="ecmult__gen_8h" local="yes">ecmult_gen.h</includes>
    <includedby refid="schnorr_2main__impl_8h" local="yes">/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/main_impl.h</includedby>
    <incdepgraph>
      <node id="52023">
        <label>scalar.h</label>
        <link refid="scalar_8h"/>
        <childnode refid="52024" relation="include">
        </childnode>
      </node>
      <node id="52022">
        <label>schnorr.h</label>
        <link refid="schnorr_8h"/>
        <childnode refid="52023" relation="include">
        </childnode>
        <childnode refid="52025" relation="include">
        </childnode>
      </node>
      <node id="52024">
        <label>num.h</label>
        <link refid="num_8h"/>
      </node>
      <node id="52025">
        <label>group.h</label>
        <link refid="group_8h"/>
        <childnode refid="52024" relation="include">
        </childnode>
        <childnode refid="52026" relation="include">
        </childnode>
      </node>
      <node id="52020">
        <label>/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h</label>
        <link refid="schnorr_impl.h"/>
        <childnode refid="52021" relation="include">
        </childnode>
        <childnode refid="52022" relation="include">
        </childnode>
        <childnode refid="52024" relation="include">
        </childnode>
        <childnode refid="52026" relation="include">
        </childnode>
        <childnode refid="52025" relation="include">
        </childnode>
        <childnode refid="52027" relation="include">
        </childnode>
        <childnode refid="52028" relation="include">
        </childnode>
      </node>
      <node id="52027">
        <label>ecmult.h</label>
        <link refid="ecmult_8h"/>
        <childnode refid="52024" relation="include">
        </childnode>
        <childnode refid="52025" relation="include">
        </childnode>
      </node>
      <node id="52021">
        <label>string.h</label>
      </node>
      <node id="52028">
        <label>ecmult_gen.h</label>
        <link refid="ecmult__gen_8h"/>
        <childnode refid="52023" relation="include">
        </childnode>
        <childnode refid="52025" relation="include">
        </childnode>
      </node>
      <node id="52026">
        <label>field.h</label>
        <link refid="field_8h"/>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="52029">
        <label>/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h</label>
        <link refid="schnorr_impl.h"/>
        <childnode refid="52030" relation="include">
        </childnode>
      </node>
      <node id="52030">
        <label>/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/main_impl.h</label>
        <link refid="schnorr_2main__impl_8h"/>
      </node>
    </invincdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="schnorr__impl_8h_1ab58ca77446a7d8daff985d07d43e7175" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_schnorr_sig_sign</definition>
        <argsstring>(const secp256k1_ecmult_gen_context *ctx, unsigned char *sig64, const secp256k1_scalar *key, const secp256k1_scalar *nonce, const secp256k1_ge *pubnonce, secp256k1_schnorr_msghash hash, const unsigned char *msg32)</argsstring>
        <name>secp256k1_schnorr_sig_sign</name>
        <param>
          <type>const <ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>sig64</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>key</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>nonce</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>pubnonce</declname>
        </param>
        <param>
          <type><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref></type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Custom Schnorr-based signature scheme. They support multiparty signing, public key recovery and batch validation.</para><para>Rationale for verifying R&apos;s y coordinate: In order to support batch validation and public key recovery, the full R point must be known to verifiers, rather than just its x coordinate. In order to not risk being more strict in batch validation than normal validation, validators must be required to reject signatures with incorrect y coordinate. This is only possible by including a (relatively slow) field inverse, or a field square root. However, batch validation offers potentially much higher benefits than this cost.</para><para>Rationale for having an implicit y coordinate oddness: If we commit to having the full R point known to verifiers, there are two mechanism. Either include its oddness in the signature, or give it an implicit fixed value. As the R y coordinate can be flipped by a simple negation of the nonce, we choose the latter, as it comes with nearly zero impact on signing or validation performance, and saves a byte in the signature.</para><para>Signing: Inputs: 32-byte message m, 32-byte scalar key x (!=0), 32-byte scalar nonce k (!=0)</para><para>Compute point R = k * G. Reject nonce if R&apos;s y coordinate is odd (or negate nonce). Compute 32-byte r, the serialization of R&apos;s x coordinate. Compute scalar h = Hash(r || m). Reject nonce if h == 0 or h &gt;= order. Compute scalar s = k - h * x. The signature is (r, s).</para><para>Verification: Inputs: 32-byte message m, public key point Q, signature: (32-byte r, scalar s)</para><para>Signature is invalid if s &gt;= order. Signature is invalid if r &gt;= p. Compute scalar h = Hash(r || m). Signature is invalid if h == 0 or h &gt;= order. Option 1 (faster for single verification): Compute point R = h * Q + s * G. Signature is invalid if R is infinity or R&apos;s y coordinate is odd. Signature is valid if the serialization of R&apos;s x coordinate equals r. Option 2 (allows batch validation and pubkey recovery): Decompress x coordinate r into point R, with odd y coordinate. Fail if R is not on the curve. Signature is valid if R + h * Q + s * G == 0. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" line="62" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" bodystart="62" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="schnorr__impl_8h_1ad8ac32b20746524ea3b97ab609117daa" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_schnorr_sig_verify</definition>
        <argsstring>(const secp256k1_ecmult_context *ctx, const unsigned char *sig64, const secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32)</argsstring>
        <name>secp256k1_schnorr_sig_verify</name>
        <param>
          <type>const <ref refid="structsecp256k1__ecmult__context" kindref="compound">secp256k1_ecmult_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>sig64</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref></type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" line="106" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" bodystart="106" bodyend="142"/>
      </memberdef>
      <memberdef kind="function" id="schnorr__impl_8h_1a41cf1a1167f3b8c7b6fdd4fea6abdbce" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_schnorr_sig_recover</definition>
        <argsstring>(const secp256k1_ecmult_context *ctx, const unsigned char *sig64, secp256k1_ge *pubkey, secp256k1_schnorr_msghash hash, const unsigned char *msg32)</argsstring>
        <name>secp256k1_schnorr_sig_recover</name>
        <param>
          <type>const <ref refid="structsecp256k1__ecmult__context" kindref="compound">secp256k1_ecmult_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>sig64</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref></type>
          <declname>hash</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" line="144" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" bodystart="144" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="schnorr__impl_8h_1ad2c15e4e57e6bf00cde3a4b229330b12" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_schnorr_sig_combine</definition>
        <argsstring>(unsigned char *sig64, size_t n, const unsigned char *const *sig64ins)</argsstring>
        <name>secp256k1_schnorr_sig_combine</name>
        <param>
          <type>unsigned char *</type>
          <declname>sig64</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <param>
          <type>const unsigned char *const *</type>
          <declname>sig64ins</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" line="181" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h" bodystart="181" bodyend="205"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/***********************************************************************</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2014-2015<sp/>Pieter<sp/>Wuille<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Distributed<sp/>under<sp/>the<sp/>MIT<sp/>software<sp/>license,<sp/>see<sp/>the<sp/>accompanying<sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>file<sp/>COPYING<sp/>or<sp/>http://www.opensource.org/licenses/mit-license.php.<sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>***********************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>_SECP256K1_SCHNORR_IMPL_H_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>_SECP256K1_SCHNORR_IMPL_H_</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="schnorr_8h" kindref="compound">schnorr.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="num_8h" kindref="compound">num.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="field_8h" kindref="compound">field.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="group_8h" kindref="compound">group.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult_8h" kindref="compound">ecmult.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__gen_8h" kindref="compound">ecmult_gen.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_schnorr_sig_sign(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*sig64,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*key,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>*nonce,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*pubnonce,<sp/><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref><sp/><ref refid="cache_8cc_1a11ecb029164e055f28f4123ce3748862" kindref="member">hash</ref>,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32)<sp/>{</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>Rj;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Ra;</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>h32[32];</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>h,<sp/>s;</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>n;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_scalar_is_zero(key)<sp/>||<sp/>secp256k1_scalar_is_zero(nonce))<sp/>{</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/>n<sp/>=<sp/>*nonce;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen(ctx,<sp/>&amp;Rj,<sp/>&amp;n);</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(pubnonce<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_add_ge(&amp;Rj,<sp/>&amp;Rj,<sp/>pubnonce);</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(&amp;Ra,<sp/>&amp;Rj);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_fe_normalize(&amp;Ra.<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>);</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_fe_is_odd(&amp;Ra.<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>))<sp/>{</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>R&apos;s<sp/>y<sp/>coordinate<sp/>is<sp/>odd,<sp/>which<sp/>is<sp/>not<sp/>allowed<sp/>(see<sp/>rationale<sp/>above).</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Force<sp/>it<sp/>to<sp/>be<sp/>even<sp/>by<sp/>negating<sp/>the<sp/>nonce.<sp/>Note<sp/>that<sp/>this<sp/>even<sp/>works</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>multiparty<sp/>signing,<sp/>as<sp/>the<sp/>R<sp/>point<sp/>is<sp/>known<sp/>to<sp/>all<sp/>participants,</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>which<sp/>can<sp/>all<sp/>decide<sp/>to<sp/>flip<sp/>the<sp/>sign<sp/>in<sp/>unison,<sp/>resulting<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>overall<sp/>R<sp/>point<sp/>to<sp/>be<sp/>negated<sp/>too.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;n,<sp/>&amp;n);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_fe_normalize(&amp;Ra.<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>);</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_fe_get_b32(sig64,<sp/>&amp;Ra.<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>);</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cache_8cc_1a11ecb029164e055f28f4123ce3748862" kindref="member">hash</ref>(h32,<sp/>sig64,<sp/>msg32);</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;h,<sp/>h32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow<sp/>||<sp/>secp256k1_scalar_is_zero(&amp;h))<sp/>{</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;n);</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_mul(&amp;s,<sp/>&amp;h,<sp/>key);</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;s,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_add(&amp;s,<sp/>&amp;s,<sp/>&amp;n);</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;n);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(sig64<sp/>+<sp/>32,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="104"><highlight class="normal">}</highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_schnorr_sig_verify(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecmult__context" kindref="compound">secp256k1_ecmult_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*sig64,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*pubkey,<sp/><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref><sp/>hash,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32)<sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>Qj,<sp/>Rj;</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Ra;</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>Rx;</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>h,<sp/>s;</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>hh[32];</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ge_is_infinity(pubkey))<sp/>{</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cache_8cc_1a11ecb029164e055f28f4123ce3748862" kindref="member">hash</ref>(hh,<sp/>sig64,<sp/>msg32);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;h,<sp/>hh,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow<sp/>||<sp/>secp256k1_scalar_is_zero(&amp;h))<sp/>{</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;s,<sp/>sig64<sp/>+<sp/>32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow)<sp/>{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_fe_set_b32(&amp;Rx,<sp/>sig64))<sp/>{</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_set_ge(&amp;Qj,<sp/>pubkey);</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult(ctx,<sp/>&amp;Rj,<sp/>&amp;Qj,<sp/>&amp;h,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_gej_is_infinity(&amp;Rj))<sp/>{</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej_var(&amp;Ra,<sp/>&amp;Rj);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_fe_normalize_var(&amp;Ra.<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>);</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_fe_is_odd(&amp;Ra.<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>))<sp/>{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_fe_equal_var(&amp;Rx,<sp/>&amp;Ra.<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>);</highlight></codeline>
<codeline lineno="142"><highlight class="normal">}</highlight></codeline>
<codeline lineno="143"><highlight class="normal"></highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_schnorr_sig_recover(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecmult__context" kindref="compound">secp256k1_ecmult_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*sig64,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>*pubkey,<sp/><ref refid="schnorr_8h_1a4543078e8c14fe94160f35b293dff0e4" kindref="member">secp256k1_schnorr_msghash</ref><sp/>hash,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32)<sp/>{</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>Qj,<sp/>Rj;</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Ra;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>Rx;</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>h,<sp/>s;</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>hh[32];</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cache_8cc_1a11ecb029164e055f28f4123ce3748862" kindref="member">hash</ref>(hh,<sp/>sig64,<sp/>msg32);</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;h,<sp/>hh,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow<sp/>||<sp/>secp256k1_scalar_is_zero(&amp;h))<sp/>{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;s,<sp/>sig64<sp/>+<sp/>32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow)<sp/>{</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_fe_set_b32(&amp;Rx,<sp/>sig64))<sp/>{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_ge_set_xo_var(&amp;Ra,<sp/>&amp;Rx,<sp/>0))<sp/>{</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_set_ge(&amp;Rj,<sp/>&amp;Ra);</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_inverse_var(&amp;h,<sp/>&amp;h);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;s,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_mul(&amp;s,<sp/>&amp;s,<sp/>&amp;h);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult(ctx,<sp/>&amp;Qj,<sp/>&amp;Rj,<sp/>&amp;h,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_gej_is_infinity(&amp;Qj))<sp/>{</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(pubkey,<sp/>&amp;Qj);</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="179"><highlight class="normal">}</highlight></codeline>
<codeline lineno="180"><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_schnorr_sig_combine(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*sig64,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*sig64ins)<sp/>{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>s<sp/>=<sp/><ref refid="scalar__4x64_8h_1aacfea2d1debc522154567ac4ac7b4fc9" kindref="member">SECP256K1_SCALAR_CONST</ref>(0,<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0,<sp/>0);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>si;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;si,<sp/>sig64ins[i]<sp/>+<sp/>32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(overflow)<sp/>{</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(i)<sp/>{</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(memcmp(sig64ins[i<sp/>-<sp/>1],<sp/>sig64ins[i],<sp/>32)<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_add(&amp;s,<sp/>&amp;s,<sp/>&amp;si);</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_scalar_is_zero(&amp;s))<sp/>{</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(sig64,<sp/>sig64ins[0],<sp/>32);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(sig64<sp/>+<sp/>32,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;s);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="205"><highlight class="normal">}</highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="/home/dev/ds-160209/src/secp256k1/src/modules/schnorr/schnorr_impl.h"/>
  </compounddef>
</doxygen>
