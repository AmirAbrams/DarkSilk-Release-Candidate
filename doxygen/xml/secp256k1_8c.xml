<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.9.1">
  <compounddef id="secp256k1_8c" kind="file" language="C++">
    <compoundname>secp256k1.c</compoundname>
    <includes refid="secp256k1_8h" local="yes">include/secp256k1.h</includes>
    <includes refid="secp256k1_2src_2util_8h" local="yes">util.h</includes>
    <includes refid="num__impl_8h" local="yes">num_impl.h</includes>
    <includes refid="field__impl_8h" local="yes">field_impl.h</includes>
    <includes refid="scalar__impl_8h" local="yes">scalar_impl.h</includes>
    <includes refid="group__impl_8h" local="yes">group_impl.h</includes>
    <includes refid="ecmult__impl_8h" local="yes">ecmult_impl.h</includes>
    <includes refid="ecmult__const__impl_8h" local="yes">ecmult_const_impl.h</includes>
    <includes refid="ecmult__gen__impl_8h" local="yes">ecmult_gen_impl.h</includes>
    <includes refid="ecdsa__impl_8h" local="yes">ecdsa_impl.h</includes>
    <includes refid="eckey__impl_8h" local="yes">eckey_impl.h</includes>
    <includes refid="hash__impl_8h" local="yes">hash_impl.h</includes>
    <includedby refid="bench__internal_8c" local="yes">/home/dev/ds-160209/src/secp256k1/src/bench_internal.c</includedby>
    <includedby refid="tests_8c" local="yes">/home/dev/ds-160209/src/secp256k1/src/tests.c</includedby>
    <incdepgraph>
      <node id="52134">
        <label>scalar.h</label>
        <link refid="scalar_8h"/>
        <childnode refid="52128" relation="include">
        </childnode>
      </node>
      <node id="52136">
        <label>ecmult_impl.h</label>
        <link refid="ecmult__impl_8h"/>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52137" relation="include">
        </childnode>
      </node>
      <node id="52124">
        <label>stdlib.h</label>
      </node>
      <node id="52130">
        <label>scalar_impl.h</label>
        <link refid="scalar__impl_8h"/>
        <childnode refid="52131" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52134" relation="include">
        </childnode>
      </node>
      <node id="52128">
        <label>num.h</label>
        <link refid="num_8h"/>
      </node>
      <node id="52121">
        <label>include/secp256k1.h</label>
        <link refid="secp256k1_8h"/>
        <childnode refid="52122" relation="include">
        </childnode>
      </node>
      <node id="52132">
        <label>group.h</label>
        <link refid="group_8h"/>
        <childnode refid="52128" relation="include">
        </childnode>
        <childnode refid="52133" relation="include">
        </childnode>
      </node>
      <node id="52142">
        <label>hash_impl.h</label>
        <link refid="hash__impl_8h"/>
        <childnode refid="52143" relation="include">
        </childnode>
        <childnode refid="52124" relation="include">
        </childnode>
        <childnode refid="52125" relation="include">
        </childnode>
        <childnode refid="52131" relation="include">
        </childnode>
      </node>
      <node id="52122">
        <label>stddef.h</label>
      </node>
      <node id="52120">
        <label>/home/dev/ds-160209/src/secp256k1/src/secp256k1.c</label>
        <link refid="secp256k1.c"/>
        <childnode refid="52121" relation="include">
        </childnode>
        <childnode refid="52123" relation="include">
        </childnode>
        <childnode refid="52127" relation="include">
        </childnode>
        <childnode refid="52129" relation="include">
        </childnode>
        <childnode refid="52130" relation="include">
        </childnode>
        <childnode refid="52135" relation="include">
        </childnode>
        <childnode refid="52136" relation="include">
        </childnode>
        <childnode refid="52138" relation="include">
        </childnode>
        <childnode refid="52140" relation="include">
        </childnode>
        <childnode refid="52144" relation="include">
        </childnode>
        <childnode refid="52146" relation="include">
        </childnode>
        <childnode refid="52142" relation="include">
        </childnode>
      </node>
      <node id="52137">
        <label>ecmult.h</label>
        <link refid="ecmult_8h"/>
        <childnode refid="52128" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
      </node>
      <node id="52135">
        <label>group_impl.h</label>
        <link refid="group__impl_8h"/>
        <childnode refid="52131" relation="include">
        </childnode>
        <childnode refid="52128" relation="include">
        </childnode>
        <childnode refid="52133" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
      </node>
      <node id="52131">
        <label>string.h</label>
      </node>
      <node id="52127">
        <label>num_impl.h</label>
        <link refid="num__impl_8h"/>
        <childnode refid="52128" relation="include">
        </childnode>
      </node>
      <node id="52141">
        <label>ecmult_gen.h</label>
        <link refid="ecmult__gen_8h"/>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
      </node>
      <node id="52143">
        <label>hash.h</label>
        <link refid="secp256k1_2src_2hash_8h"/>
        <childnode refid="52124" relation="include">
        </childnode>
        <childnode refid="52125" relation="include">
        </childnode>
      </node>
      <node id="52146">
        <label>eckey_impl.h</label>
        <link refid="eckey__impl_8h"/>
        <childnode refid="52147" relation="include">
        </childnode>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52133" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52141" relation="include">
        </childnode>
      </node>
      <node id="52123">
        <label>util.h</label>
        <link refid="secp256k1_2src_2util_8h"/>
        <childnode refid="52124" relation="include">
        </childnode>
        <childnode refid="52125" relation="include">
        </childnode>
        <childnode refid="52126" relation="include">
        </childnode>
      </node>
      <node id="52138">
        <label>ecmult_const_impl.h</label>
        <link refid="ecmult__const__impl_8h"/>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52139" relation="include">
        </childnode>
        <childnode refid="52136" relation="include">
        </childnode>
      </node>
      <node id="52145">
        <label>ecdsa.h</label>
        <link refid="ecdsa_8h"/>
        <childnode refid="52122" relation="include">
        </childnode>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52137" relation="include">
        </childnode>
      </node>
      <node id="52133">
        <label>field.h</label>
        <link refid="field_8h"/>
      </node>
      <node id="52125">
        <label>stdint.h</label>
        <link refid="stdint_8h"/>
      </node>
      <node id="52139">
        <label>ecmult_const.h</label>
        <link refid="ecmult__const_8h"/>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
      </node>
      <node id="52129">
        <label>field_impl.h</label>
        <link refid="field__impl_8h"/>
        <childnode refid="52123" relation="include">
        </childnode>
      </node>
      <node id="52147">
        <label>eckey.h</label>
        <link refid="eckey_8h"/>
        <childnode refid="52122" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52137" relation="include">
        </childnode>
        <childnode refid="52141" relation="include">
        </childnode>
      </node>
      <node id="52140">
        <label>ecmult_gen_impl.h</label>
        <link refid="ecmult__gen__impl_8h"/>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52141" relation="include">
        </childnode>
        <childnode refid="52142" relation="include">
        </childnode>
      </node>
      <node id="52144">
        <label>ecdsa_impl.h</label>
        <link refid="ecdsa__impl_8h"/>
        <childnode refid="52134" relation="include">
        </childnode>
        <childnode refid="52133" relation="include">
        </childnode>
        <childnode refid="52132" relation="include">
        </childnode>
        <childnode refid="52137" relation="include">
        </childnode>
        <childnode refid="52141" relation="include">
        </childnode>
        <childnode refid="52145" relation="include">
        </childnode>
      </node>
      <node id="52126">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <invincdepgraph>
      <node id="52150">
        <label>/home/dev/ds-160209/src/secp256k1/src/tests.c</label>
        <link refid="tests_8c"/>
      </node>
      <node id="52148">
        <label>/home/dev/ds-160209/src/secp256k1/src/secp256k1.c</label>
        <link refid="secp256k1.c"/>
        <childnode refid="52149" relation="include">
        </childnode>
        <childnode refid="52150" relation="include">
        </childnode>
      </node>
      <node id="52149">
        <label>/home/dev/ds-160209/src/secp256k1/src/bench_internal.c</label>
        <link refid="bench__internal_8c"/>
      </node>
    </invincdepgraph>
    <innerclass refid="structsecp256k1__context__struct" prot="public">secp256k1_context_struct</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="secp256k1_8c_1a1c49db739b76634ccbd0db4233e6cd8a" prot="public" static="no">
        <name>SECP256K1_BUILD</name>
        <initializer>(1)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="7" column="9" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="7" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" prot="public" static="no">
        <name>ARG_CHECK</name>
        <param><defname>cond</defname></param>
        <initializer>do { \
    if (<ref refid="secp256k1_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>(!(cond), 0)) { \
        secp256k1_callback_call(&amp;ctx-&gt;illegal_callback, #cond); \
        return 0; \
    } \
} while(0)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="23" column="9" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="23" bodyend="-1"/>
        <referencedby refid="ecdh_2main__impl_8h_1aeb1a1fa5ba08b7f43e5f60a1bf2cb76d" compoundref="ecdh_2main__impl_8h" startline="13" endline="52">secp256k1_ecdh</referencedby>
        <referencedby refid="recovery_2main__impl_8h_1a37101568f72e98d7b29de6c6a825a289" compoundref="recovery_2main__impl_8h" startline="38" endline="58">secp256k1_ecdsa_recoverable_signature_parse_compact</referencedby>
        <referencedby refid="recovery_2main__impl_8h_1ac122392fa6ff6264a7a110875af164b0" compoundref="recovery_2main__impl_8h" startline="60" endline="72">secp256k1_ecdsa_recoverable_signature_serialize_compact</referencedby>
        <referencedby refid="recovery_2main__impl_8h_1a16ddfc800140d761bc783e571c34548c" compoundref="recovery_2main__impl_8h" startline="74" endline="85">secp256k1_ecdsa_recoverable_signature_convert</referencedby>
        <referencedby refid="recovery_2main__impl_8h_1ae06d019b6eaa34e248a502ba9c6d04cb" compoundref="recovery_2main__impl_8h" startline="123" endline="168">secp256k1_ecdsa_sign_recoverable</referencedby>
        <referencedby refid="recovery_2main__impl_8h_1a75f3e32e9a25eac9e8f9d3a5a8b0dc94" compoundref="recovery_2main__impl_8h" startline="170" endline="191">secp256k1_ecdsa_recover</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a0d7ae4600f16da7c9464c80fefc72072" compoundref="schnorr_2main__impl_8h" startline="23" endline="59">secp256k1_schnorr_sign</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a5d23afb11115cb53171b34da09ff3ad0" compoundref="schnorr_2main__impl_8h" startline="61" endline="71">secp256k1_schnorr_verify</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1aa4480a44de97ffc056712ea9fd9631c5" compoundref="schnorr_2main__impl_8h" startline="73" endline="89">secp256k1_schnorr_recover</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a67c4e4b188db3530c2e8808162f3a3c5" compoundref="schnorr_2main__impl_8h" startline="91" endline="131">secp256k1_schnorr_generate_nonce_pair</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a6787237abf20a26c8c2fb195102ce810" compoundref="schnorr_2main__impl_8h" startline="133" endline="155">secp256k1_schnorr_partial_sign</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a7dd43d7414424c68563e14d0bda8e867" compoundref="schnorr_2main__impl_8h" startline="157" endline="162">secp256k1_schnorr_partial_combine</referencedby>
        <referencedby refid="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" compoundref="secp256k1_8c" startline="152" endline="166">secp256k1_ec_pubkey_parse</referencedby>
        <referencedby refid="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" compoundref="secp256k1_8c" startline="168" endline="190">secp256k1_ec_pubkey_serialize</referencedby>
        <referencedby refid="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" compoundref="secp256k1_8c" startline="216" endline="230">secp256k1_ecdsa_signature_parse_der</referencedby>
        <referencedby refid="secp256k1_8c_1a933083356e7171e174bc958b8233f758" compoundref="secp256k1_8c" startline="232" endline="251">secp256k1_ecdsa_signature_parse_compact</referencedby>
        <referencedby refid="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" compoundref="secp256k1_8c" startline="253" endline="263">secp256k1_ecdsa_signature_serialize_der</referencedby>
        <referencedby refid="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" compoundref="secp256k1_8c" startline="265" endline="276">secp256k1_ecdsa_signature_serialize_compact</referencedby>
        <referencedby refid="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" compoundref="secp256k1_8c" startline="278" endline="295">secp256k1_ecdsa_signature_normalize</referencedby>
        <referencedby refid="secp256k1_8c_1aef3f50927cd80005b797fa234338db73" compoundref="secp256k1_8c" startline="297" endline="312">secp256k1_ecdsa_verify</referencedby>
        <referencedby refid="secp256k1_8c_1ad33367933638f0bda3387c76867df7d5" compoundref="secp256k1_8c" startline="349" endline="393">secp256k1_ecdsa_sign</referencedby>
        <referencedby refid="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" compoundref="secp256k1_8c" startline="395" endline="407">secp256k1_ec_seckey_verify</referencedby>
        <referencedby refid="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" compoundref="secp256k1_8c" startline="409" endline="430">secp256k1_ec_pubkey_create</referencedby>
        <referencedby refid="secp256k1_8c_1a0473f3a4e2e7f8a1b91d1925bcf7a1b5" compoundref="secp256k1_8c" startline="432" endline="454">secp256k1_ec_privkey_tweak_add</referencedby>
        <referencedby refid="secp256k1_8c_1ae298cd31c7f5f3e12a1adb27c4831c68" compoundref="secp256k1_8c" startline="456" endline="478">secp256k1_ec_pubkey_tweak_add</referencedby>
        <referencedby refid="secp256k1_8c_1ae7185df9e614559d35394a8a195b78c6" compoundref="secp256k1_8c" startline="480" endline="501">secp256k1_ec_privkey_tweak_mul</referencedby>
        <referencedby refid="secp256k1_8c_1a6d391761d8c1cb4875d6d0b348d31cec" compoundref="secp256k1_8c" startline="503" endline="525">secp256k1_ec_pubkey_tweak_mul</referencedby>
        <referencedby refid="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" compoundref="secp256k1_8c" startline="527" endline="532">secp256k1_context_randomize</referencedby>
        <referencedby refid="secp256k1_8c_1a92498665c38198fc1943e463c017c140" compoundref="secp256k1_8c" startline="534" endline="556">secp256k1_ec_pubkey_combine</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="secp256k1_8c_1afa49ffaa7c5709207930319e21185392" prot="public" static="yes" mutable="no">
        <type>const <ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref></type>
        <definition>const secp256k1_callback default_illegal_callback</definition>
        <argsstring></argsstring>
        <name>default_illegal_callback</name>
        <initializer>= {
    default_illegal_callback_fn,
    NULL
}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="36" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a792961430f27e8b9178105a7ec023019" prot="public" static="yes" mutable="no">
        <type>const <ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref></type>
        <definition>const secp256k1_callback default_error_callback</definition>
        <argsstring></argsstring>
        <name>default_error_callback</name>
        <initializer>= {
    default_error_callback_fn,
    NULL
}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="47" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="47" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a2ac052a733aac60ef5c19f1f79e3c1dd" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
        <definition>const secp256k1_nonce_function secp256k1_nonce_function_rfc6979</definition>
        <argsstring></argsstring>
        <name>secp256k1_nonce_function_rfc6979</name>
        <initializer>= nonce_function_rfc6979</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>An implementation of RFC6979 (using HMAC-SHA256) as nonce generation function. If a data pointer is passed, it is assumed to be a pointer to 32 bytes of extra entropy. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="346" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="346" bodyend="-1"/>
        <referencedby refid="class_c_key_1a3b161899b4fa79f5a7036d2ccf12ce3a" compoundref="key_8cpp" startline="182" endline="195">CKey::Sign</referencedby>
        <referencedby refid="class_c_key_1a59afeabf3f63d99dfdbd3722087853a1" compoundref="key_8cpp" startline="211" endline="224">CKey::SignCompact</referencedby>
      </memberdef>
      <memberdef kind="variable" id="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" prot="public" static="no" mutable="no">
        <type>const <ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
        <definition>const secp256k1_nonce_function secp256k1_nonce_function_default</definition>
        <argsstring></argsstring>
        <name>secp256k1_nonce_function_default</name>
        <initializer>= nonce_function_rfc6979</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A default safe nonce generation function (currently equal to secp256k1_nonce_function_rfc6979). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="347" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="347" bodyend="-1"/>
        <referencedby refid="recovery_2main__impl_8h_1ae06d019b6eaa34e248a502ba9c6d04cb" compoundref="recovery_2main__impl_8h" startline="123" endline="168">secp256k1_ecdsa_sign_recoverable</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a0d7ae4600f16da7c9464c80fefc72072" compoundref="schnorr_2main__impl_8h" startline="23" endline="59">secp256k1_schnorr_sign</referencedby>
        <referencedby refid="schnorr_2main__impl_8h_1a67c4e4b188db3530c2e8808162f3a3c5" compoundref="schnorr_2main__impl_8h" startline="91" endline="131">secp256k1_schnorr_generate_nonce_pair</referencedby>
        <referencedby refid="secp256k1_8c_1ad33367933638f0bda3387c76867df7d5" compoundref="secp256k1_8c" startline="349" endline="393">secp256k1_ecdsa_sign</referencedby>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="secp256k1_8c_1a66c010ece461590245c65fdd55390dbd" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void default_illegal_callback_fn</definition>
        <argsstring>(const char *str, void *data)</argsstring>
        <name>default_illegal_callback_fn</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="30" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="30" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa6e98398cd5dd5398aab826a8d3bc740" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void default_error_callback_fn</definition>
        <argsstring>(const char *str, void *data)</argsstring>
        <name>default_error_callback_fn</name>
        <param>
          <type>const char *</type>
          <declname>str</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="41" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="41" bodyend="45"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a2d23dd6eb961e47720ec8db63da8044b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context* secp256k1_context_create</definition>
        <argsstring>(unsigned int flags)</argsstring>
        <name>secp256k1_context_create</name>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a secp256k1 context object.</para><para>Returns: a newly created context object. In: flags: which parts of the context to initialize. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="60" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="60" bodyend="83"/>
        <references refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" compoundref="secp256k1_8c" startline="56">secp256k1_context_struct::illegal_callback</references>
        <references refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" compoundref="secp256k1_8c" startline="57">secp256k1_context_struct::error_callback</references>
        <references refid="secp256k1_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" compoundref="secp256k1_2src_2util_8h" startline="42">EXPECT</references>
        <references refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" compoundref="secp256k1_8h" startline="151">SECP256K1_FLAGS_TYPE_MASK</references>
        <references refid="secp256k1_8h_1ad96f13de52c4c94f5d11d53fd04c529f" compoundref="secp256k1_8h" startline="152">SECP256K1_FLAGS_TYPE_CONTEXT</references>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <references refid="secp256k1_8h_1ab516743de74b08ccbeea17fb5f783bc9" compoundref="secp256k1_8h" startline="156">SECP256K1_FLAGS_BIT_CONTEXT_SIGN</references>
        <references refid="secp256k1_8h_1aabde1ec66215bb0474821343583e1fb2" compoundref="secp256k1_8h" startline="155">SECP256K1_FLAGS_BIT_CONTEXT_VERIFY</references>
        <referencedby refid="key_8h_1a5ee69136607b1012d64a045ee44ccae2" compoundref="key_8cpp" startline="321" endline="338">ECC_Start</referencedby>
        <referencedby refid="class_e_c_c_verify_handle_1a01404b41eee891c1dea4b58db02e56fb" compoundref="pubkey_8cpp" startline="285" endline="293">ECCVerifyHandle::ECCVerifyHandle</referencedby>
        <referencedby refid="bench__internal_8c_1a0267a6fcf26df5e2625c0f93eed876a9" compoundref="bench__internal_8c" startline="286" endline="292">bench_context_verify</referencedby>
        <referencedby refid="bench__internal_8c_1a0d6ae07fc12e8c74ebdcb49871cbfc0e" compoundref="bench__internal_8c" startline="294" endline="300">bench_context_sign</referencedby>
        <referencedby refid="bench__recover_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__recover_8c" startline="51" endline="60">main</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6c00dac7dd6dc157d019e47d73882ab7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
        <definition>secp256k1_context* secp256k1_context_clone</definition>
        <argsstring>(const secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_clone</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copies a secp256k1 context object.</para><para>Returns: a newly created context object. Args: ctx: an existing context to copy (cannot be NULL) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="85" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="85" bodyend="92"/>
        <references refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" compoundref="secp256k1_8c" startline="57">secp256k1_context_struct::error_callback</references>
        <references refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" compoundref="secp256k1_8c" startline="56">secp256k1_context_struct::illegal_callback</references>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac80c186f8ff22d87441240267a2c8100" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_destroy</definition>
        <argsstring>(secp256k1_context *ctx)</argsstring>
        <name>secp256k1_context_destroy</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy a secp256k1 context object.</para><para>The context pointer may not be used afterwards. Args: ctx: an existing context to destroy (cannot be NULL) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="94" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="94" bodyend="101"/>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <referencedby refid="key_8h_1a8fb68c634cf5491218253147eb4e04c8" compoundref="key_8cpp" startline="340" endline="347">ECC_Stop</referencedby>
        <referencedby refid="class_e_c_c_verify_handle_1a17dea6c87a0f825f0f24a06a20e2baf9" compoundref="pubkey_8cpp" startline="295" endline="303">ECCVerifyHandle::~ECCVerifyHandle</referencedby>
        <referencedby refid="bench__internal_8c_1a0267a6fcf26df5e2625c0f93eed876a9" compoundref="bench__internal_8c" startline="286" endline="292">bench_context_verify</referencedby>
        <referencedby refid="bench__internal_8c_1a0d6ae07fc12e8c74ebdcb49871cbfc0e" compoundref="bench__internal_8c" startline="294" endline="300">bench_context_sign</referencedby>
        <referencedby refid="bench__recover_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__recover_8c" startline="51" endline="60">main</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a947ba36e0fe0bced91d4c9a7ef3b1f09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_set_illegal_callback</definition>
        <argsstring>(secp256k1_context *ctx, void(*fun)(const char *message, void *data), const void *data)</argsstring>
        <name>secp256k1_context_set_illegal_callback</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>void(*)(const char *message, void *data)</type>
          <declname>fun</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a callback function to be called when an illegal argument is passed to an API call. It will only trigger for violations that are mentioned explicitly in the header.</para><para>The philosophy is that these shouldn&apos;t be dealt with through a specific return value, as calling code should not have branches to deal with the case that this code itself is broken.</para><para>On the other hand, during debug stage, one would want to be informed about such mistakes, and the default (crashing) may be inadvisable. When this callback is triggered, the API function called is guaranteed not to cause a crash, though its return value and output arguments are undefined.</para><para>Args: ctx: an existing context object (cannot be NULL) In: fun: a pointer to a function to call when an illegal argument is passed to the API, taking a message and an opaque pointer (NULL restores a default handler that calls abort). data: the opaque pointer to pass to fun above. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="103" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="103" bodyend="109"/>
        <references refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" compoundref="secp256k1_8c" startline="56">secp256k1_context_struct::illegal_callback</references>
        <references refid="structsecp256k1__callback_1ab53dda8f586b668b302a0955de4de44c" compoundref="secp256k1_2src_2util_8h" startline="19">secp256k1_callback::fn</references>
        <references refid="structsecp256k1__callback_1acd5a72114709ca9841ad31f88c1744bc" compoundref="secp256k1_2src_2util_8h" startline="20">secp256k1_callback::data</references>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1ab33610b81949f135f12a8f2aab3dc192" compoundref="tests_8c" startline="2561" endline="2634">ec_pubkey_parse_pointtest</referencedby>
        <referencedby refid="tests_8c_1a24bd2af11fcef9c3f2abb62862d6fe97" compoundref="tests_8c" startline="2636" endline="2961">run_ec_pubkey_parse_test</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a7384d60163d08fae0c5e8d1e1fdef60a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void secp256k1_context_set_error_callback</definition>
        <argsstring>(secp256k1_context *ctx, void(*fun)(const char *message, void *data), const void *data)</argsstring>
        <name>secp256k1_context_set_error_callback</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>void(*)(const char *message, void *data)</type>
          <declname>fun</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Set a callback function to be called when an internal consistency check fails. The default is crashing.</para><para>This can only trigger in case of a hardware failure, miscompilation, memory corruption, serious bug in the library, or other error would can otherwise result in undefined behaviour. It will not trigger due to mere incorrect usage of the API (see secp256k1_context_set_illegal_callback for that). After this callback returns, anything may happen, including crashing.</para><para>Args: ctx: an existing context object (cannot be NULL) In: fun: a pointer to a function to call when an internal error occurs, taking a message and an opaque pointer (NULL restores a default handler that calls abort). data: the opaque pointer to pass to fun above. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="111" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="111" bodyend="117"/>
        <references refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" compoundref="secp256k1_8c" startline="57">secp256k1_context_struct::error_callback</references>
        <references refid="structsecp256k1__callback_1ab53dda8f586b668b302a0955de4de44c" compoundref="secp256k1_2src_2util_8h" startline="19">secp256k1_callback::fn</references>
        <references refid="structsecp256k1__callback_1acd5a72114709ca9841ad31f88c1744bc" compoundref="secp256k1_2src_2util_8h" startline="20">secp256k1_callback::data</references>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a9966ec041e71010d1593ae2211ffb843" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int secp256k1_pubkey_load</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ge *ge, const secp256k1_pubkey *pubkey)</argsstring>
        <name>secp256k1_pubkey_load</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>ge</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="119" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="119" bodyend="136"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aa061c9c5c861017bef990e5c4653e0f4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_pubkey_save</definition>
        <argsstring>(secp256k1_pubkey *pubkey, secp256k1_ge *ge)</argsstring>
        <name>secp256k1_pubkey_save</name>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref> *</type>
          <declname>ge</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="138" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="138" bodyend="150"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_parse</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *input, size_t inputlen)</argsstring>
        <name>secp256k1_ec_pubkey_parse</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>inputlen</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a variable-length public key into the pubkey object.</para><para>Returns: 1 if the public key was fully valid. 0 if the public key could not be parsed or is invalid. Args: ctx: a secp256k1 context object. Out: pubkey: pointer to a pubkey object. If 1 is returned, it is set to a parsed version of input. If not, its value is undefined. In: input: pointer to a serialized public key inputlen: length of the array pointed to by input</para><para>This function supports parsing compressed (33 bytes, header byte 0x02 or 0x03), uncompressed (65 bytes, header byte 0x04), or hybrid (65 bytes, header byte 0x06 or 0x07) format public keys. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="152" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="152" bodyend="166"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="class_c_pub_key_1ab4047c7ce31b72591d8108a2563cd21b" compoundref="pubkey_8cpp" startline="167" endline="185">CPubKey::Verify</referencedby>
        <referencedby refid="class_c_pub_key_1a2533ec5fc9a1c3d2ef39d0faa3ad6cdd" compoundref="pubkey_8cpp" startline="207" endline="212">CPubKey::IsFullyValid</referencedby>
        <referencedby refid="class_c_pub_key_1a572689418fecf47b300a11519bc3da36" compoundref="pubkey_8cpp" startline="214" endline="226">CPubKey::Decompress</referencedby>
        <referencedby refid="class_c_pub_key_1a182298237bb189abfe006e2ff3350acc" compoundref="pubkey_8cpp" startline="228" endline="247">CPubKey::Derive</referencedby>
        <referencedby refid="tests_8c_1ab33610b81949f135f12a8f2aab3dc192" compoundref="tests_8c" startline="2561" endline="2634">ec_pubkey_parse_pointtest</referencedby>
        <referencedby refid="tests_8c_1a24bd2af11fcef9c3f2abb62862d6fe97" compoundref="tests_8c" startline="2636" endline="2961">run_ec_pubkey_parse_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_serialize</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_pubkey *pubkey, unsigned int flags)</argsstring>
        <name>secp256k1_ec_pubkey_serialize</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>outputlen</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>flags</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize a pubkey object into a serialized byte sequence.</para><para>Returns: 1 always. Args: ctx: a secp256k1 context object. Out: output: a pointer to a 65-byte (if compressed==0) or 33-byte (if compressed==1) byte array to place the serialized key in. In/Out: outputlen: a pointer to an integer which is initially set to the size of output, and is overwritten with the written size. In: pubkey: a pointer to a <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> containing an initialized public key. flags: SECP256K1_EC_COMPRESSED if serialization should be in compressed format, otherwise SECP256K1_EC_UNCOMPRESSED. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="168" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="168" bodyend="190"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="secp256k1_8h_1ac26f7c3f665e6422a651d2eb910f1a03" compoundref="secp256k1_8h" startline="157">SECP256K1_FLAGS_BIT_COMPRESSION</references>
        <references refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" compoundref="secp256k1_8h" startline="151">SECP256K1_FLAGS_TYPE_MASK</references>
        <references refid="secp256k1_8h_1af8d4e9ca93634062735b7f998ef9f68a" compoundref="secp256k1_8h" startline="153">SECP256K1_FLAGS_TYPE_COMPRESSION</references>
        <referencedby refid="class_c_key_1ae4b61da6ec62f676fe6362ac5fc26aca" compoundref="key_8cpp" startline="169" endline="180">CKey::GetPubKey</referencedby>
        <referencedby refid="class_c_pub_key_1a169505e735a02db385486b0affeb565c" compoundref="pubkey_8cpp" startline="187" endline="205">CPubKey::RecoverCompact</referencedby>
        <referencedby refid="class_c_pub_key_1a572689418fecf47b300a11519bc3da36" compoundref="pubkey_8cpp" startline="214" endline="226">CPubKey::Decompress</referencedby>
        <referencedby refid="class_c_pub_key_1a182298237bb189abfe006e2ff3350acc" compoundref="pubkey_8cpp" startline="228" endline="247">CPubKey::Derive</referencedby>
        <referencedby refid="lax__der__privatekey__parsing_8h_1ab0172ae6ae0adcf65b3d94960ece8e31" compoundref="lax__der__privatekey__parsing_8c" startline="56" endline="113">ec_privkey_export_der</referencedby>
        <referencedby refid="bench__recover_8c_1a6bbc6888c36d93d55e5410b25121db10" compoundref="bench__recover_8c" startline="18" endline="37">bench_recover</referencedby>
        <referencedby refid="bench__verify_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__verify_8c" startline="43" endline="68">main</referencedby>
        <referencedby refid="ecdh_2tests__impl_8h_1ab13157e14f777c18f14fefc834d067c5" compoundref="ecdh_2tests__impl_8h" startline="10" endline="42">test_ecdh_generator_basepoint</referencedby>
        <referencedby refid="tests_8c_1ab33610b81949f135f12a8f2aab3dc192" compoundref="tests_8c" startline="2561" endline="2634">ec_pubkey_parse_pointtest</referencedby>
        <referencedby refid="tests_8c_1a24bd2af11fcef9c3f2abb62862d6fe97" compoundref="tests_8c" startline="2636" endline="2961">run_ec_pubkey_parse_test</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1af2027241c9dfc85fa5b6a3bb5fe41d18" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecdsa_signature_load</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_scalar *r, secp256k1_scalar *s, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_load</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="192" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="192" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a94e522f94c4819bebf8e854952eb6a8f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void secp256k1_ecdsa_signature_save</definition>
        <argsstring>(secp256k1_ecdsa_signature *sig, const secp256k1_scalar *r, const secp256k1_scalar *s)</argsstring>
        <name>secp256k1_ecdsa_signature_save</name>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="206" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="206" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_parse_der</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input, size_t inputlen)</argsstring>
        <name>secp256k1_ecdsa_signature_parse_der</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>inputlen</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse a DER ECDSA signature.</para><para>Returns: 1 when the signature could be parsed, 0 otherwise. Args: ctx: a secp256k1 context object Out: sig: a pointer to a signature object In: input: a pointer to the signature to be parsed inputlen: the length of the array pointed to be input</para><para>This function will accept any valid DER encoded signature, even if the encoded numbers are out of range.</para><para>After the call, sig will always be initialized. If parsing failed or the encoded numbers are out of range, signature validation with it is guaranteed to fail for every message and public key. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="216" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="216" bodyend="230"/>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="recovery_2tests__impl_8h_1ad6d3138600637a7c940bc40a22795e46" compoundref="recovery_2tests__impl_8h" startline="69" endline="240">test_ecdsa_recovery_edge_cases</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1a1cb741ffd2cea46124f7abc2c506717a" compoundref="tests_8c" startline="3485" endline="3593">test_ecdsa_der_parse</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a933083356e7171e174bc958b8233f758" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_parse_compact</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sig, const unsigned char *input64)</argsstring>
        <name>secp256k1_ecdsa_signature_parse_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>input64</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parse an ECDSA signature in compact (64 bytes) format.</para><para>Returns: 1 when the signature could be parsed, 0 otherwise. Args: ctx: a secp256k1 context object Out: sig: a pointer to a signature object In: input64: a pointer to the 64-byte array to parse</para><para>The signature must consist of a 32-byte big endian R value, followed by a 32-byte big endian S value. If R or S fall outside of [0..order-1], the encoding is invalid. R and S with value 0 are allowed in the encoding.</para><para>After the call, sig will always be initialized. If parsing failed or R or S are zero, the resulting sig value is guaranteed to fail validation for any message and public key. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="232" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="232" bodyend="251"/>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="lax__der__parsing_8h_1a8c6e1225540c46bf7080cabde2c4e691" compoundref="lax__der__parsing_8c" startline="12" endline="149">ecdsa_signature_parse_der_lax</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_serialize_der</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output, size_t *outputlen, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_serialize_der</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output</declname>
        </param>
        <param>
          <type>size_t *</type>
          <declname>outputlen</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize an ECDSA signature in DER format.</para><para>Returns: 1 if enough space was available to serialize, 0 otherwise Args: ctx: a secp256k1 context object Out: output: a pointer to an array to store the DER serialization In/Out: outputlen: a pointer to a length integer. Initially, this integer should be set to the length of output. After the call it will be set to the length of the serialization (even if 0 was returned). In: sig: a pointer to an initialized signature object </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="253" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="253" bodyend="263"/>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="class_c_key_1a3b161899b4fa79f5a7036d2ccf12ce3a" compoundref="key_8cpp" startline="182" endline="195">CKey::Sign</referencedby>
        <referencedby refid="bench__verify_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__verify_8c" startline="43" endline="68">main</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1a1cb741ffd2cea46124f7abc2c506717a" compoundref="tests_8c" startline="3485" endline="3593">test_ecdsa_der_parse</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_serialize_compact</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *output64, const secp256k1_ecdsa_signature *sig)</argsstring>
        <name>secp256k1_ecdsa_signature_serialize_compact</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>output64</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Serialize an ECDSA signature in compact (64 byte) format.</para><para>Returns: 1 Args: ctx: a secp256k1 context object Out: output64: a pointer to a 64-byte array to store the compact serialization In: sig: a pointer to an initialized signature object</para><para>See secp256k1_ecdsa_signature_parse_compact for details about the encoding. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="265" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="265" bodyend="276"/>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="tests_8c_1a1cb741ffd2cea46124f7abc2c506717a" compoundref="tests_8c" startline="3485" endline="3593">test_ecdsa_der_parse</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_signature_normalize</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *sigout, const secp256k1_ecdsa_signature *sigin)</argsstring>
        <name>secp256k1_ecdsa_signature_normalize</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sigout</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sigin</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Convert a signature to a normalized lower-S form.</para><para>Returns: 1 if sigin was not normalized, 0 if it already was. Args: ctx: a secp256k1 context object Out: sigout: a pointer to a signature to fill with the normalized form, or copy if the input was already normalized. (can be NULL if you&apos;re only interested in whether the input was already normalized). In: sigin: a pointer to a signature to check/normalize (cannot be NULL, can be identical to sigout)</para><para>With ECDSA a third-party can forge a second distinct signature of the same message, given a single initial signature, but without knowing the key. This is done by negating the S value modulo the order of the curve, &apos;flipping&apos; the sign of the random point R which is not included in the signature.</para><para>Forgery of the same message isn&apos;t universally problematic, but in systems where message malleability or uniqueness of signatures is important this can cause issues. This forgery can be blocked by all verifiers forcing signers to use a normalized form.</para><para>The lower-S form reduces the size of signatures slightly on average when variable length encodings (such as DER) are used and is cheap to verify, making it a good choice. Security of always using lower-S is assured because anyone can trivially modify a signature after the fact to enforce this property anyway.</para><para>The lower S value is always between 0x1 and 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, inclusive.</para><para>No other forms of ECDSA malleability are known and none seem likely, but there is no formal proof that ECDSA, even with this additional restriction, is free of other malleability. Commonly used serialization schemes will also accept various non-unique encodings, so care should be taken when this property is required for an application.</para><para>The secp256k1_ecdsa_sign function will by default create signatures in the lower-S form, and secp256k1_ecdsa_verify will not accept others. In case signatures come from a system that cannot enforce this property, secp256k1_ecdsa_signature_normalize must be called before verification. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="278" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="278" bodyend="295"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="class_c_pub_key_1ab4047c7ce31b72591d8108a2563cd21b" compoundref="pubkey_8cpp" startline="167" endline="185">CPubKey::Verify</referencedby>
        <referencedby refid="class_c_pub_key_1a4ada230ef593456ef9088c28fd5ca34e" compoundref="pubkey_8cpp" startline="275" endline="281">CPubKey::CheckLowS</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aef3f50927cd80005b797fa234338db73" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_verify</definition>
        <argsstring>(const secp256k1_context *ctx, const secp256k1_ecdsa_signature *sig, const unsigned char *msg32, const secp256k1_pubkey *pubkey)</argsstring>
        <name>secp256k1_ecdsa_verify</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Verify an ECDSA signature.</para><para>Returns: 1: correct signature 0: incorrect or unparseable signature Args: ctx: a secp256k1 context object, initialized for verification. In: sig: the signature being verified (cannot be NULL) msg32: the 32-byte message hash being verified (cannot be NULL) pubkey: pointer to an initialized public key to verify with (cannot be NULL)</para><para>To avoid accepting malleable signatures, only ECDSA signatures in lower-S form are accepted.</para><para>If you need to accept ECDSA signatures from sources that do not obey this rule, apply secp256k1_ecdsa_signature_normalize to the signature prior to validation, but be aware that doing so results in malleable signatures.</para><para>For details, see the comments for that function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="297" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="297" bodyend="312"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <referencedby refid="class_c_pub_key_1ab4047c7ce31b72591d8108a2563cd21b" compoundref="pubkey_8cpp" startline="167" endline="185">CPubKey::Verify</referencedby>
        <referencedby refid="org__bitcoin___native_secp256k1_8h_1a89cf56a82147cd1a9e6ec85a20827288" compoundref="org__bitcoin___native_secp256k1_8c" startline="5" endline="12">Java_org_bitcoin_NativeSecp256k1_secp256k1_1ecdsa_1verify</referencedby>
        <referencedby refid="recovery_2tests__impl_8h_1a70649882936497184992dfaa06b1106f" compoundref="recovery_2tests__impl_8h" startline="10" endline="66">test_ecdsa_recovery_end_to_end</referencedby>
        <referencedby refid="recovery_2tests__impl_8h_1ad6d3138600637a7c940bc40a22795e46" compoundref="recovery_2tests__impl_8h" startline="69" endline="240">test_ecdsa_recovery_edge_cases</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aaeed37b3a1d669fc6031755d37a5b2c4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int nonce_function_rfc6979</definition>
        <argsstring>(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter)</argsstring>
        <name>nonce_function_rfc6979</name>
        <param>
          <type>unsigned char *</type>
          <declname>nonce32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>key32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>algo16</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>counter</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="314" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="314" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ad33367933638f0bda3387c76867df7d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ecdsa_sign</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_ecdsa_signature *signature, const unsigned char *msg32, const unsigned char *seckey, secp256k1_nonce_function noncefp, const void *noncedata)</argsstring>
        <name>secp256k1_ecdsa_sign</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref> *</type>
          <declname>sig</declname>
          <defname>signature</defname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>msg32</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref></type>
          <declname>noncefp</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>ndata</declname>
          <defname>noncedata</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create an ECDSA signature.</para><para>Returns: 1: signature created 0: the nonce generation function failed, or the private key was invalid. Args: ctx: pointer to a context object, initialized for signing (cannot be NULL) Out: sig: pointer to an array where the signature will be placed (cannot be NULL) In: msg32: the 32-byte message hash being signed (cannot be NULL) seckey: pointer to a 32-byte secret key (cannot be NULL) noncefp:pointer to a nonce generation function. If NULL, secp256k1_nonce_function_default is used ndata: pointer to arbitrary data used by the nonce generation function (can be NULL)</para><para>The created signature is always in lower-S form. See secp256k1_ecdsa_signature_normalize for more details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="349" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="349" bodyend="393"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <references refid="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" compoundref="secp256k1_8c" startline="347">secp256k1_nonce_function_default</references>
        <referencedby refid="class_c_key_1a3b161899b4fa79f5a7036d2ccf12ce3a" compoundref="key_8cpp" startline="182" endline="195">CKey::Sign</referencedby>
        <referencedby refid="bench__verify_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__verify_8c" startline="43" endline="68">main</referencedby>
        <referencedby refid="recovery_2tests__impl_8h_1a70649882936497184992dfaa06b1106f" compoundref="recovery_2tests__impl_8h" startline="10" endline="66">test_ecdsa_recovery_end_to_end</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_seckey_verify</definition>
        <argsstring>(const secp256k1_context *ctx, const unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_seckey_verify</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Verify an ECDSA secret key.</para><para>Returns: 1: secret key is valid 0: secret key is invalid Args: ctx: pointer to a context object (cannot be NULL) In: seckey: pointer to a 32-byte secret key (cannot be NULL) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="395" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="395" bodyend="407"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="lax__der__privatekey__parsing_8h_1a73106d5c4a234faa276659a29efe11d3" compoundref="lax__der__privatekey__parsing_8c" startline="12" endline="54">ec_privkey_import_der</referencedby>
        <referencedby refid="recovery_2tests__impl_8h_1a70649882936497184992dfaa06b1106f" compoundref="recovery_2tests__impl_8h" startline="10" endline="66">test_ecdsa_recovery_end_to_end</referencedby>
        <referencedby refid="schnorr_2tests__impl_8h_1a0fadfae101d2df588a044f55eafcc0e6" compoundref="schnorr_2tests__impl_8h" startline="12" endline="40">test_schnorr_end_to_end</referencedby>
        <referencedby refid="schnorr_2tests__impl_8h_1a7c79e0204a103b99844bdf1b2ac4cb57" compoundref="schnorr_2tests__impl_8h" startline="85" endline="144">test_schnorr_threshold</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_create</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *seckey)</argsstring>
        <name>secp256k1_ec_pubkey_create</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Compute the public key for a secret key.</para><para>Returns: 1: secret was valid, public key stores 0: secret was invalid, try again Args: ctx: pointer to a context object, initialized for signing (cannot be NULL) Out: pubkey: pointer to the created public key (cannot be NULL) In: seckey: pointer to a 32-byte private key (cannot be NULL) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="409" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="409" bodyend="430"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <referencedby refid="class_c_key_1ae4b61da6ec62f676fe6362ac5fc26aca" compoundref="key_8cpp" startline="169" endline="180">CKey::GetPubKey</referencedby>
        <referencedby refid="lax__der__privatekey__parsing_8h_1ab0172ae6ae0adcf65b3d94960ece8e31" compoundref="lax__der__privatekey__parsing_8c" startline="56" endline="113">ec_privkey_export_der</referencedby>
        <referencedby refid="bench__verify_8c_1a840291bc02cba5474a4cb46a9b9566fe" compoundref="bench__verify_8c" startline="43" endline="68">main</referencedby>
        <referencedby refid="ecdh_2tests__impl_8h_1ab13157e14f777c18f14fefc834d067c5" compoundref="ecdh_2tests__impl_8h" startline="10" endline="42">test_ecdh_generator_basepoint</referencedby>
        <referencedby refid="ecdh_2tests__impl_8h_1a505bff7cea922e6d8aa4f7525cfd191a" compoundref="ecdh_2tests__impl_8h" startline="44" endline="68">test_bad_scalar</referencedby>
        <referencedby refid="recovery_2tests__impl_8h_1a70649882936497184992dfaa06b1106f" compoundref="recovery_2tests__impl_8h" startline="10" endline="66">test_ecdsa_recovery_end_to_end</referencedby>
        <referencedby refid="schnorr_2tests__impl_8h_1a0fadfae101d2df588a044f55eafcc0e6" compoundref="schnorr_2tests__impl_8h" startline="12" endline="40">test_schnorr_end_to_end</referencedby>
        <referencedby refid="schnorr_2tests__impl_8h_1a7c79e0204a103b99844bdf1b2ac4cb57" compoundref="schnorr_2tests__impl_8h" startline="85" endline="144">test_schnorr_threshold</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
        <referencedby refid="tests_8c_1abbcb27d1eb13654db9b2e281ffce021e" compoundref="tests_8c" startline="3811" endline="4178">test_ecdsa_edge_cases</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a0473f3a4e2e7f8a1b91d1925bcf7a1b5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_privkey_tweak_add</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak)</argsstring>
        <name>secp256k1_ec_privkey_tweak_add</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a private key by adding tweak to it. Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting private key would be invalid (only when the tweak is the complement of the private key). 1 otherwise. Args: ctx: pointer to a context object (cannot be NULL). In/Out: seckey: pointer to a 32-byte private key. In: tweak: pointer to a 32-byte tweak. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="432" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="432" bodyend="454"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="class_c_key_1abb0091d4390dcece3c56ea4c1fdd6036" compoundref="key_8cpp" startline="238" endline="258">CKey::Derive</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ae298cd31c7f5f3e12a1adb27c4831c68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_tweak_add</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak)</argsstring>
        <name>secp256k1_ec_pubkey_tweak_add</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a public key by adding tweak times the generator to it. Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or if the resulting public key would be invalid (only when the tweak is the complement of the corresponding private key). 1 otherwise. Args: ctx: pointer to a context object initialized for validation (cannot be NULL). In/Out: pubkey: pointer to a public key object. In: tweak: pointer to a 32-byte tweak. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="456" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="456" bodyend="478"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <referencedby refid="class_c_pub_key_1a182298237bb189abfe006e2ff3350acc" compoundref="pubkey_8cpp" startline="228" endline="247">CPubKey::Derive</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1ae7185df9e614559d35394a8a195b78c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_privkey_tweak_mul</definition>
        <argsstring>(const secp256k1_context *ctx, unsigned char *seckey, const unsigned char *tweak)</argsstring>
        <name>secp256k1_ec_privkey_tweak_mul</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>seckey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a private key by multiplying it by a tweak. Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or equal to zero. 1 otherwise. Args: ctx: pointer to a context object (cannot be NULL). In/Out: seckey: pointer to a 32-byte private key. In: tweak: pointer to a 32-byte tweak. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="480" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="480" bodyend="501"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a6d391761d8c1cb4875d6d0b348d31cec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_tweak_mul</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubkey, const unsigned char *tweak)</argsstring>
        <name>secp256k1_ec_pubkey_tweak_mul</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>pubkey</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>tweak</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Tweak a public key by multiplying it by a tweak value. Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for uniformly random 32-byte arrays, or equal to zero. 1 otherwise. Args: ctx: pointer to a context object initialized for validation (cannot be NULL). In/Out: pubkey: pointer to a public key obkect. In: tweak: pointer to a 32-byte tweak. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="503" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="503" bodyend="525"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" compoundref="secp256k1_8c" startline="54">secp256k1_context_struct::ecmult_ctx</references>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
        <referencedby refid="tests_8c_1a3fc9dc1908215215a68690ea1bfa8bcd" compoundref="tests_8c" startline="3288" endline="3409">test_ecdsa_end_to_end</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_context_randomize</definition>
        <argsstring>(secp256k1_context *ctx, const unsigned char *seed32)</argsstring>
        <name>secp256k1_context_randomize</name>
        <param>
          <type><ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const unsigned char *</type>
          <declname>seed32</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Updates the context randomization. Returns: 1: randomization successfully updated 0: error Args: ctx: pointer to a context object (cannot be NULL) In: seed32: pointer to a 32-byte random seed (NULL resets to initial state) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="527" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="527" bodyend="532"/>
        <references refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" compoundref="secp256k1_2src_2util_8h" startline="64">VERIFY_CHECK</references>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <references refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" compoundref="secp256k1_8c" startline="55">secp256k1_context_struct::ecmult_gen_ctx</references>
        <referencedby refid="key_8h_1a5ee69136607b1012d64a045ee44ccae2" compoundref="key_8cpp" startline="321" endline="338">ECC_Start</referencedby>
        <referencedby refid="tests_8c_1a2f9713526b1e988694c6e2026a6fce69" compoundref="tests_8c" startline="136" endline="237">run_context_tests</referencedby>
        <referencedby refid="tests_8c_1a3c04138a5bfe5d72780bb7e82a18e627" compoundref="tests_8c" startline="4252" endline="4383">main</referencedby>
      </memberdef>
      <memberdef kind="function" id="secp256k1_8c_1a92498665c38198fc1943e463c017c140" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int secp256k1_ec_pubkey_combine</definition>
        <argsstring>(const secp256k1_context *ctx, secp256k1_pubkey *pubnonce, const secp256k1_pubkey *const *pubnonces, size_t n)</argsstring>
        <name>secp256k1_ec_pubkey_combine</name>
        <param>
          <type>const <ref refid="secp256k1_8h_1a282ec9e6dfec8c35955c3eb2f7476e5e" kindref="member">secp256k1_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *</type>
          <declname>out</declname>
          <defname>pubnonce</defname>
        </param>
        <param>
          <type>const <ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref> *const *</type>
          <declname>ins</declname>
          <defname>pubnonces</defname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Add a number of public keys together. Returns: 1: the sum of the public keys is valid. 0: the sum of the public keys is not valid. Args: ctx: pointer to a context object Out: out: pointer to a public key object for placing the resulting public key (cannot be NULL) In: ins: pointer to array of pointers to public keys (cannot be NULL) n: the number of public keys to add together (must be at least 1) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" line="534" column="1" bodyfile="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c" bodystart="534" bodyend="556"/>
        <references refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" compoundref="secp256k1_8c" startline="23">ARG_CHECK</references>
        <referencedby refid="schnorr_2tests__impl_8h_1a7c79e0204a103b99844bdf1b2ac4cb57" compoundref="schnorr_2tests__impl_8h" startline="85" endline="144">test_schnorr_threshold</referencedby>
        <referencedby refid="tests_8c_1af668387a475fa94107e316b2ddc003cf" compoundref="tests_8c" startline="2019" endline="2042">test_ec_combine</referencedby>
        <referencedby refid="tests_8c_1a32498e86a99a258f68cd4b1176f47966" compoundref="tests_8c" startline="2963" endline="3197">run_eckey_edge_case_test</referencedby>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/**********************************************************************</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2013-2016<sp/>Pieter<sp/>Wuille<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Distributed<sp/>under<sp/>the<sp/>MIT<sp/>software<sp/>license,<sp/>see<sp/>the<sp/>accompanying<sp/><sp/><sp/>*</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*<sp/>file<sp/>COPYING<sp/>or<sp/>http://www.opensource.org/licenses/mit-license.php.*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>**********************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7" refid="secp256k1_8c_1a1c49db739b76634ccbd0db4233e6cd8a" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SECP256K1_BUILD<sp/>(1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_8h" kindref="compound">include/secp256k1.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="secp256k1_2src_2util_8h" kindref="compound">util.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="num__impl_8h" kindref="compound">num_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="field__impl_8h" kindref="compound">field_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="scalar__impl_8h" kindref="compound">scalar_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="group__impl_8h" kindref="compound">group_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__impl_8h" kindref="compound">ecmult_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__const__impl_8h" kindref="compound">ecmult_const_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecmult__gen__impl_8h" kindref="compound">ecmult_gen_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="ecdsa__impl_8h" kindref="compound">ecdsa_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="eckey__impl_8h" kindref="compound">eckey_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="hash__impl_8h" kindref="compound">hash_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23" refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" refkind="member"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ARG_CHECK(cond)<sp/>do<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="24"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>if<sp/>(EXPECT(!(cond),<sp/>0))<sp/>{<sp/>\</highlight></codeline>
<codeline lineno="25"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;ctx-&gt;illegal_callback,<sp/>#cond);<sp/>\</highlight></codeline>
<codeline lineno="26"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>0;<sp/>\</highlight></codeline>
<codeline lineno="27"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>}<sp/>\</highlight></codeline>
<codeline lineno="28"><highlight class="preprocessor">}<sp/>while(0)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>default_illegal_callback_fn(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)data;</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;[libsecp256k1]<sp/>illegal<sp/>argument:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>str);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/>abort();</highlight></codeline>
<codeline lineno="34"><highlight class="normal">}</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/>default_illegal_callback<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/>default_illegal_callback_fn,</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/>NULL</highlight></codeline>
<codeline lineno="39"><highlight class="normal">};</highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>default_error_callback_fn(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>str,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)data;</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;[libsecp256k1]<sp/>internal<sp/>consistency<sp/>check<sp/>failed:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>str);</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/>abort();</highlight></codeline>
<codeline lineno="45"><highlight class="normal">}</highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/>default_error_callback<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>default_error_callback_fn,</highlight></codeline>
<codeline lineno="49"><highlight class="normal"><sp/><sp/><sp/><sp/>NULL</highlight></codeline>
<codeline lineno="50"><highlight class="normal">};</highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight></codeline>
<codeline lineno="53" refid="structsecp256k1__context__struct" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context_struct</ref><sp/>{</highlight></codeline>
<codeline lineno="54" refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecmult__context" kindref="compound">secp256k1_ecmult_context</ref><sp/><ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>;</highlight></codeline>
<codeline lineno="55" refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ecmult__gen__context" kindref="compound">secp256k1_ecmult_gen_context</ref><sp/><ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>;</highlight></codeline>
<codeline lineno="56" refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/><ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref>;</highlight></codeline>
<codeline lineno="57" refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" refkind="member"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__callback" kindref="compound">secp256k1_callback</ref><sp/><ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>;</highlight></codeline>
<codeline lineno="58"><highlight class="normal">};</highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight></codeline>
<codeline lineno="60" refid="secp256k1_8c_1a2d23dd6eb961e47720ec8db63da8044b" refkind="member"><highlight class="normal"><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1a2d23dd6eb961e47720ec8db63da8044b" kindref="member">secp256k1_context_create</ref>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flags)<sp/>{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ret<sp/>=<sp/>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*)checked_malloc(&amp;default_error_callback,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>));</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/>ret-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref><sp/>=<sp/>default_illegal_callback;</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/>ret-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref><sp/>=<sp/>default_error_callback;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="secp256k1_2src_2util_8h_1a76e8a689f16456e44a2cc438a6821025" kindref="member">EXPECT</ref>((flags<sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" kindref="member">SECP256K1_FLAGS_TYPE_MASK</ref>)<sp/>!=<sp/><ref refid="secp256k1_8h_1ad96f13de52c4c94f5d11d53fd04c529f" kindref="member">SECP256K1_FLAGS_TYPE_CONTEXT</ref>,<sp/>0))<sp/>{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_callback_call(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref>,</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>flags&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(ret);</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="71"><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_context_init(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_init(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>);</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab516743de74b08ccbeea17fb5f783bc9" kindref="member">SECP256K1_FLAGS_BIT_CONTEXT_SIGN</ref>)<sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_build(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>);</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(flags<sp/>&amp;<sp/><ref refid="secp256k1_8h_1aabde1ec66215bb0474821343583e1fb2" kindref="member">SECP256K1_FLAGS_BIT_CONTEXT_VERIFY</ref>)<sp/>{</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_context_build(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="83"><highlight class="normal">}</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="85" refid="secp256k1_8c_1a6c00dac7dd6dc157d019e47d73882ab7" refkind="member"><highlight class="normal"><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/><ref refid="secp256k1_8c_1a6c00dac7dd6dc157d019e47d73882ab7" kindref="member">secp256k1_context_clone</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ret<sp/>=<sp/>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*)checked_malloc(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>));</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/>ret-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref><sp/>=<sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref>;</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/>ret-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref><sp/>=<sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>;</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_context_clone(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>);</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_clone(&amp;ret-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>);</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="92"><highlight class="normal">}</highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="94" refid="secp256k1_8c_1ac80c186f8ff22d87441240267a2c8100" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac80c186f8ff22d87441240267a2c8100" kindref="member">secp256k1_context_destroy</ref>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx)<sp/>{</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ctx<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_context_clear(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_context_clear(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(ctx);</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="101"><highlight class="normal">}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103" refid="secp256k1_8c_1a947ba36e0fe0bced91d4c9a7ef3b1f09" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a947ba36e0fe0bced91d4c9a7ef3b1f09" kindref="member">secp256k1_context_set_illegal_callback</ref>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(*fun)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data),<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fun<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fun<sp/>=<sp/>default_illegal_callback_fn;</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref>.<ref refid="structsecp256k1__callback_1ab53dda8f586b668b302a0955de4de44c" kindref="member">fn</ref><sp/>=<sp/>fun;</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1a6f73572b18e62b306c5699e9e1470ab5" kindref="member">illegal_callback</ref>.<ref refid="structsecp256k1__callback_1acd5a72114709ca9841ad31f88c1744bc" kindref="member">data</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="109"><highlight class="normal">}</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111" refid="secp256k1_8c_1a7384d60163d08fae0c5e8d1e1fdef60a" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a7384d60163d08fae0c5e8d1e1fdef60a" kindref="member">secp256k1_context_set_error_callback</ref>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>(*fun)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">*<sp/>message,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data),<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>data)<sp/>{</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fun<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fun<sp/>=<sp/>default_error_callback_fn;</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>.<ref refid="structsecp256k1__callback_1ab53dda8f586b668b302a0955de4de44c" kindref="member">fn</ref><sp/>=<sp/>fun;</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>ctx-&gt;<ref refid="structsecp256k1__context__struct_1aa34a996f869676899e8625adfb6c6f1d" kindref="member">error_callback</ref>.<ref refid="structsecp256k1__callback_1acd5a72114709ca9841ad31f88c1744bc" kindref="member">data</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="117"><highlight class="normal">}</highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>secp256k1_pubkey_load(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref>*<sp/>ge,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey)<sp/>{</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__ge__storage" kindref="compound">secp256k1_ge_storage</ref>)<sp/>==<sp/>64)<sp/>{</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>When<sp/>the<sp/>secp256k1_ge_storage<sp/>type<sp/>is<sp/>exactly<sp/>64<sp/>byte,<sp/>use<sp/>its</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>representation<sp/>inside<sp/>secp256k1_pubkey,<sp/>as<sp/>conversion<sp/>is<sp/>very<sp/>fast.</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>Note<sp/>that<sp/>secp256k1_pubkey_save<sp/>must<sp/>use<sp/>the<sp/>same<sp/>representation.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge__storage" kindref="compound">secp256k1_ge_storage</ref><sp/>s;</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;s,<sp/>&amp;pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref>[0],<sp/>64);</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_from_storage(ge,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Otherwise,<sp/>fall<sp/>back<sp/>to<sp/>32-byte<sp/>big<sp/>endian<sp/>for<sp/>X<sp/>and<sp/>Y.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__fe" kindref="compound">secp256k1_fe</ref><sp/>x,<sp/>y;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_set_b32(&amp;x,<sp/>pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref>);</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_set_b32(&amp;y,<sp/>pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref><sp/>+<sp/>32);</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_set_xy(ge,<sp/>&amp;x,<sp/>&amp;y);</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(!secp256k1_fe_is_zero(&amp;ge-&gt;<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>));</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="136"><highlight class="normal">}</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_pubkey_save(<ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref>*<sp/>ge)<sp/>{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__ge__storage" kindref="compound">secp256k1_ge_storage</ref>)<sp/>==<sp/>64)<sp/>{</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge__storage" kindref="compound">secp256k1_ge_storage</ref><sp/>s;</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_to_storage(&amp;s,<sp/>ge);</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref>[0],<sp/>&amp;s,<sp/>64);</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(!secp256k1_ge_is_infinity(ge));</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_normalize_var(&amp;ge-&gt;<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_normalize_var(&amp;ge-&gt;<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>);</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_get_b32(pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref>,<sp/>&amp;ge-&gt;<ref refid="structsecp256k1__ge_1a3c04a97b606c82ea87e55d4a06f06b6e" kindref="member">x</ref>);</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_fe_get_b32(pubkey-&gt;<ref refid="structsecp256k1__pubkey_1a337cef146cd8002610da4b04a91ee7ce" kindref="member">data</ref><sp/>+<sp/>32,<sp/>&amp;ge-&gt;<ref refid="structsecp256k1__ge_1a604295983a1f4aa6e8b5b0f1e46f9ee0" kindref="member">y</ref>);</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="150"><highlight class="normal">}</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152" refid="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a4a359778a7faf65fba9d34db17642d20" kindref="member">secp256k1_ec_pubkey_parse</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>inputlen)<sp/>{</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!secp256k1_eckey_pubkey_parse(&amp;Q,<sp/>input,<sp/>inputlen))<sp/>{</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_clear(&amp;Q);</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="166"><highlight class="normal">}</highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="168" refid="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a3b0440ba2ccd06e9262b94b41b680df1" kindref="member">secp256k1_ec_pubkey_serialize</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*outputlen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref>*<sp/>pubkey,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flags)<sp/>{</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>len;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(outputlen<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(*outputlen<sp/>&gt;=<sp/>((flags<sp/>&amp;<sp/><ref refid="secp256k1_8h_1ac26f7c3f665e6422a651d2eb910f1a03" kindref="member">SECP256K1_FLAGS_BIT_COMPRESSION</ref>)<sp/>?<sp/>33<sp/>:<sp/>65));</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>len<sp/>=<sp/>*outputlen;</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/>*outputlen<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(output,<sp/>0,<sp/>len);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>((flags<sp/>&amp;<sp/><ref refid="secp256k1_8h_1ab2572c9f38f9a644f2933f7b74a5072f" kindref="member">SECP256K1_FLAGS_TYPE_MASK</ref>)<sp/>==<sp/><ref refid="secp256k1_8h_1af8d4e9ca93634062735b7f998ef9f68a" kindref="member">SECP256K1_FLAGS_TYPE_COMPRESSION</ref>);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_pubkey_load(ctx,<sp/>&amp;Q,<sp/>pubkey))<sp/>{</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>secp256k1_eckey_pubkey_serialize(&amp;Q,<sp/>output,<sp/>&amp;len,<sp/>flags<sp/>&amp;<sp/>SECP256K1_FLAGS_BIT_COMPRESSION);</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*outputlen<sp/>=<sp/>len;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="190"><highlight class="normal">}</highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_signature_load(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>r,<sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>s,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>)<sp/>==<sp/>32)<sp/>{</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>When<sp/>the<sp/>secp256k1_scalar<sp/>type<sp/>is<sp/>exactly<sp/>32<sp/>byte,<sp/>use<sp/>its</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>representation<sp/>inside<sp/>secp256k1_ecdsa_signature,<sp/>as<sp/>conversion<sp/>is<sp/>very<sp/>fast.</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>Note<sp/>that<sp/>secp256k1_ecdsa_signature_save<sp/>must<sp/>use<sp/>the<sp/>same<sp/>representation.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(r,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[0],<sp/>32);</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(s,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[32],<sp/>32);</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(r,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[0],<sp/>NULL);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(s,<sp/>&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[32],<sp/>NULL);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="204"><highlight class="normal">}</highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_signature_save(<ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>r,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>*<sp/>s)<sp/>{</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref>)<sp/>==<sp/>32)<sp/>{</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[0],<sp/>r,<sp/>32);</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[32],<sp/>s,<sp/>32);</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[0],<sp/>r);</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;sig-&gt;<ref refid="structsecp256k1__ecdsa__signature_1a80f750e6d473a8d43c77e53757893f15" kindref="member">data</ref>[32],<sp/>s);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="214"><highlight class="normal">}</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight></codeline>
<codeline lineno="216" refid="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a7bd08fb7f758494d5011849b6ca0ef13" kindref="member">secp256k1_ecdsa_signature_parse_der</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>inputlen)<sp/>{</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ecdsa_sig_parse(&amp;r,<sp/>&amp;s,<sp/>input,<sp/>inputlen))<sp/>{</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sig,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(sig,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*sig));</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="230"><highlight class="normal">}</highlight></codeline>
<codeline lineno="231"><highlight class="normal"></highlight></codeline>
<codeline lineno="232" refid="secp256k1_8c_1a933083356e7171e174bc958b8233f758" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a933083356e7171e174bc958b8233f758" kindref="member">secp256k1_ecdsa_signature_parse_compact</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*input64)<sp/>{</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(input64<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;r,<sp/>&amp;input64[0],<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>&amp;=<sp/>!overflow;</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;s,<sp/>&amp;input64[32],<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>&amp;=<sp/>!overflow;</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sig,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(sig,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*sig));</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="251"><highlight class="normal">}</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="253" refid="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a3f1fbd9cfe9bd6b6303bdd8f6c0687ba" kindref="member">secp256k1_ecdsa_signature_serialize_der</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>*outputlen,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(outputlen<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"></highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>secp256k1_ecdsa_sig_serialize(output,<sp/>outputlen,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="263"><highlight class="normal">}</highlight></codeline>
<codeline lineno="264"><highlight class="normal"></highlight></codeline>
<codeline lineno="265" refid="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac369bdcc5f8d5ced129e84895bf739db" kindref="member">secp256k1_ecdsa_signature_serialize_compact</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*output64,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref>*<sp/>sig)<sp/>{</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(output64<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="271"><highlight class="normal"></highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;output64[0],<sp/>&amp;r);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(&amp;output64[32],<sp/>&amp;s);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="276"><highlight class="normal">}</highlight></codeline>
<codeline lineno="277"><highlight class="normal"></highlight></codeline>
<codeline lineno="278" refid="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a6ebd89d119f3da65e165947573ebd3ce" kindref="member">secp256k1_ecdsa_signature_normalize</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sigout,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sigin)<sp/>{</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"></highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sigin<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sigin);</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>secp256k1_scalar_is_high(&amp;s);</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sigout<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_negate(&amp;s,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(sigout,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="293"><highlight class="normal"></highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="295"><highlight class="normal">}</highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight></codeline>
<codeline lineno="297" refid="secp256k1_8c_1aef3f50927cd80005b797fa234338db73" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1aef3f50927cd80005b797fa234338db73" kindref="member">secp256k1_ecdsa_verify</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*sig,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey)<sp/>{</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>q;</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>m;</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>));</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(msg32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(sig<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;m,<sp/>msg32,<sp/>NULL);</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_load(ctx,<sp/>&amp;r,<sp/>&amp;s,<sp/>sig);</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(!secp256k1_scalar_is_high(&amp;s)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;q,<sp/>pubkey)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_sig_verify(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;r,<sp/>&amp;s,<sp/>&amp;q,<sp/>&amp;m));</highlight></codeline>
<codeline lineno="312"><highlight class="normal">}</highlight></codeline>
<codeline lineno="313"><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nonce_function_rfc6979(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*nonce32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*key32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*algo16,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*data,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="db__test_8cc_1a62ffeaac8bdc204faeb004239f7c04be" kindref="member">counter</ref>)<sp/>{</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>keydata[112];</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>keylen<sp/>=<sp/>64;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><ref refid="structsecp256k1__rfc6979__hmac__sha256__t" kindref="compound">secp256k1_rfc6979_hmac_sha256_t</ref><sp/>rng;</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>feed<sp/>a<sp/>byte<sp/>array<sp/>to<sp/>the<sp/>PRNG<sp/>as<sp/>input,<sp/>consisting<sp/>of:</highlight></codeline>
<codeline lineno="320"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>the<sp/>private<sp/>key<sp/>(32<sp/>bytes)<sp/>and<sp/>message<sp/>(32<sp/>bytes),<sp/>see<sp/>RFC<sp/>6979<sp/>3.2d.</highlight></codeline>
<codeline lineno="321"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>optionally<sp/>32<sp/>extra<sp/>bytes<sp/>of<sp/>data,<sp/>see<sp/>RFC<sp/>6979<sp/>3.6<sp/>Additional<sp/>Data.</highlight></codeline>
<codeline lineno="322"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>-<sp/>optionally<sp/>16<sp/>extra<sp/>bytes<sp/>with<sp/>the<sp/>algorithm<sp/>name.</highlight></codeline>
<codeline lineno="323"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/>Because<sp/>the<sp/>arguments<sp/>have<sp/>distinct<sp/>fixed<sp/>lengths<sp/>it<sp/>is<sp/>not<sp/>possible<sp/>for</highlight></codeline>
<codeline lineno="324"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/>different<sp/>argument<sp/>mixtures<sp/>to<sp/>emulate<sp/>each<sp/>other<sp/>and<sp/>result<sp/>in<sp/>the<sp/>same</highlight></codeline>
<codeline lineno="325"><highlight class="comment"><sp/><sp/><sp/><sp/>*<sp/><sp/>nonces.</highlight></codeline>
<codeline lineno="326"><highlight class="comment"><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/>memcpy(keydata,<sp/>key32,<sp/>32);</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/>memcpy(keydata<sp/>+<sp/>32,<sp/>msg32,<sp/>32);</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(data<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(keydata<sp/>+<sp/>64,<sp/>data,<sp/>32);</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>keylen<sp/>=<sp/>96;</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(algo16<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(keydata<sp/>+<sp/>keylen,<sp/>algo16,<sp/>16);</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>keylen<sp/>+=<sp/>16;</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_initialize(&amp;rng,<sp/>keydata,<sp/>keylen);</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/>memset(keydata,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(keydata));</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;=<sp/><ref refid="db__test_8cc_1a62ffeaac8bdc204faeb004239f7c04be" kindref="member">counter</ref>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_generate(&amp;rng,<sp/>nonce32,<sp/>32);</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/>secp256k1_rfc6979_hmac_sha256_finalize(&amp;rng);</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="344"><highlight class="normal">}</highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight></codeline>
<codeline lineno="346" refid="secp256k1_8c_1a2ac052a733aac60ef5c19f1f79e3c1dd" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/><ref refid="secp256k1_8c_1a2ac052a733aac60ef5c19f1f79e3c1dd" kindref="member">secp256k1_nonce_function_rfc6979</ref><sp/>=<sp/>nonce_function_rfc6979;</highlight></codeline>
<codeline lineno="347" refid="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" refkind="member"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/><ref refid="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" kindref="member">secp256k1_nonce_function_default</ref><sp/>=<sp/>nonce_function_rfc6979;</highlight></codeline>
<codeline lineno="348"><highlight class="normal"></highlight></codeline>
<codeline lineno="349" refid="secp256k1_8c_1ad33367933638f0bda3387c76867df7d5" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ad33367933638f0bda3387c76867df7d5" kindref="member">secp256k1_ecdsa_sign</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__ecdsa__signature" kindref="compound">secp256k1_ecdsa_signature</ref><sp/>*signature,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*msg32,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/><ref refid="secp256k1_8h_1a539882fd91bff672712fa19a4cfaeb98" kindref="member">secp256k1_nonce_function</ref><sp/>noncefp,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*<sp/>noncedata)<sp/>{</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>r,<sp/>s;</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec,<sp/>non,<sp/>msg;</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>));</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(msg32<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(signature<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(noncefp<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>noncefp<sp/>=<sp/><ref refid="secp256k1_8c_1a28fc3fe2c4a63199be2fea7303f012a0" kindref="member">secp256k1_nonce_function_default</ref>;</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;sec,<sp/>seckey,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Fail<sp/>if<sp/>the<sp/>secret<sp/>key<sp/>is<sp/>invalid.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!overflow<sp/>&amp;&amp;<sp/>!secp256k1_scalar_is_zero(&amp;sec))<sp/>{</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;msg,<sp/>msg32,<sp/>NULL);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>nonce32[32];</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>noncefp(nonce32,<sp/>msg32,<sp/>seckey,<sp/>NULL,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)noncedata,<sp/>count);</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;non,<sp/>nonce32,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(nonce32,<sp/>0,<sp/>32);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!overflow<sp/>&amp;&amp;<sp/>!secp256k1_scalar_is_zero(&amp;non))<sp/>{</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_ecdsa_sig_sign(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;r,<sp/>&amp;s,<sp/>&amp;sec,<sp/>&amp;msg,<sp/>&amp;non,<sp/>NULL))<sp/>{</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;msg);</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;non);</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecdsa_signature_save(signature,<sp/>&amp;r,<sp/>&amp;s);</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset(signature,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*signature));</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="393"><highlight class="normal">}</highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight></codeline>
<codeline lineno="395" refid="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a6015346bdaee22c65e5ebca71693d9b1" kindref="member">secp256k1_ec_seckey_verify</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="402"><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;sec,<sp/>seckey,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>!secp256k1_scalar_is_zero(&amp;sec);</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="407"><highlight class="normal">}</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409" refid="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ac5806cffd3278e64f863027eaa8e1284" kindref="member">secp256k1_ec_pubkey_create</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey)<sp/>{</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>pj;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow;</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>));</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;sec,<sp/>seckey,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>(!overflow)<sp/>&amp;<sp/>(!secp256k1_scalar_is_zero(&amp;sec));</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>&amp;pj,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(&amp;p,<sp/>&amp;pj);</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="430"><highlight class="normal">}</highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight></codeline>
<codeline lineno="432" refid="secp256k1_8c_1a0473f3a4e2e7f8a1b91d1925bcf7a1b5" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a0473f3a4e2e7f8a1b91d1925bcf7a1b5" kindref="member">secp256k1_ec_privkey_tweak_add</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak)<sp/>{</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>term;</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;term,<sp/>tweak,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;sec,<sp/>seckey,<sp/>NULL);</highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_eckey_privkey_tweak_add(&amp;sec,<sp/>&amp;term);</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(seckey,<sp/>0,<sp/>32);</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(seckey,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;term);</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="454"><highlight class="normal">}</highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight></codeline>
<codeline lineno="456" refid="secp256k1_8c_1ae298cd31c7f5f3e12a1adb27c4831c68" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ae298cd31c7f5f3e12a1adb27c4831c68" kindref="member">secp256k1_ec_pubkey_tweak_add</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak)<sp/>{</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>term;</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>));</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="465"><highlight class="normal"></highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;term,<sp/>tweak,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;p,<sp/>pubkey);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_eckey_pubkey_tweak_add(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;p,<sp/>&amp;term))<sp/>{</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="476"><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="478"><highlight class="normal">}</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="480" refid="secp256k1_8c_1ae7185df9e614559d35394a8a195b78c6" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1ae7185df9e614559d35394a8a195b78c6" kindref="member">secp256k1_ec_privkey_tweak_mul</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seckey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak)<sp/>{</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>factor;</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>sec;</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(seckey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/>(void)ctx;</highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;factor,<sp/>tweak,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;sec,<sp/>seckey,<sp/>NULL);</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_eckey_privkey_tweak_mul(&amp;sec,<sp/>&amp;factor);</highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(seckey,<sp/>0,<sp/>32);</highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_scalar_get_b32(seckey,<sp/>&amp;sec);</highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="497"><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;sec);</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_clear(&amp;factor);</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="501"><highlight class="normal">}</highlight></codeline>
<codeline lineno="502"><highlight class="normal"></highlight></codeline>
<codeline lineno="503" refid="secp256k1_8c_1a6d391761d8c1cb4875d6d0b348d31cec" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a6d391761d8c1cb4875d6d0b348d31cec" kindref="member">secp256k1_ec_pubkey_tweak_mul</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubkey,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*tweak)<sp/>{</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>p;</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__scalar" kindref="compound">secp256k1_scalar</ref><sp/>factor;</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>overflow<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>));</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubkey<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(tweak<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="512"><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_scalar_set_b32(&amp;factor,<sp/>tweak,<sp/>&amp;overflow);</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>!overflow<sp/>&amp;&amp;<sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;p,<sp/>pubkey);</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubkey,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubkey));</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ret)<sp/>{</highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_eckey_pubkey_tweak_mul(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1ab6a825dd98cab724df0f0060cf515eab" kindref="member">ecmult_ctx</ref>,<sp/>&amp;p,<sp/>&amp;factor))<sp/>{</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubkey,<sp/>&amp;p);</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="523"><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="525"><highlight class="normal">}</highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="527" refid="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1aba25f5f986a05a1cd06f5452b26ff868" kindref="member">secp256k1_context_randomize</ref>(<ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*seed32)<sp/>{</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_2src_2util_8h_1aca8ac5ae73fd966db106de59160a178b" kindref="member">VERIFY_CHECK</ref>(ctx<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(secp256k1_ecmult_gen_context_is_built(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>));</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ecmult_gen_blind(&amp;ctx-&gt;<ref refid="structsecp256k1__context__struct_1aacc2071a68f9c5a6c05eb783f523b9eb" kindref="member">ecmult_gen_ctx</ref>,<sp/>seed32);</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="532"><highlight class="normal">}</highlight></codeline>
<codeline lineno="533"><highlight class="normal"></highlight></codeline>
<codeline lineno="534" refid="secp256k1_8c_1a92498665c38198fc1943e463c017c140" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="secp256k1_8c_1a92498665c38198fc1943e463c017c140" kindref="member">secp256k1_ec_pubkey_combine</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__context__struct" kindref="compound">secp256k1_context</ref>*<sp/>ctx,<sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*pubnonce,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structsecp256k1__pubkey" kindref="compound">secp256k1_pubkey</ref><sp/>*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>*pubnonces,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n)<sp/>{</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__gej" kindref="compound">secp256k1_gej</ref><sp/>Qj;</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsecp256k1__ge" kindref="compound">secp256k1_ge</ref><sp/>Q;</highlight></codeline>
<codeline lineno="538"><highlight class="normal"></highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubnonce<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pubnonce,<sp/>0,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(*pubnonce));</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(n<sp/>&gt;=<sp/>1);</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="secp256k1_8c_1a6e1f88c6ce07376501097b42a2b40727" kindref="member">ARG_CHECK</ref>(pubnonces<sp/>!=<sp/>NULL);</highlight></codeline>
<codeline lineno="543"><highlight class="normal"></highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_gej_set_infinity(&amp;Qj);</highlight></codeline>
<codeline lineno="545"><highlight class="normal"></highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>n;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_pubkey_load(ctx,<sp/>&amp;Q,<sp/>pubnonces[i]);</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>secp256k1_gej_add_ge(&amp;Qj,<sp/>&amp;Qj,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(secp256k1_gej_is_infinity(&amp;Qj))<sp/>{</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_ge_set_gej(&amp;Q,<sp/>&amp;Qj);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/>secp256k1_pubkey_save(pubnonce,<sp/>&amp;Q);</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="556"><highlight class="normal">}</highlight></codeline>
<codeline lineno="557"><highlight class="normal"></highlight></codeline>
<codeline lineno="558"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_ECDH</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="559"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="ecdh_2main__impl_8h" kindref="compound">modules/ecdh/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="560"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_SCHNORR</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="schnorr_2main__impl_8h" kindref="compound">modules/schnorr/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="566"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ENABLE_MODULE_RECOVERY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/>include<sp/>&quot;<ref refid="recovery_2main__impl_8h" kindref="compound">modules/recovery/main_impl.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
    </programlisting>
    <location file="/home/dev/ds-160209/src/secp256k1/src/secp256k1.c"/>
  </compounddef>
</doxygen>
